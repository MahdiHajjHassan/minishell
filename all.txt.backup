#include "inc/minishell.h"

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   builtin.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mahajj-h <mahajj-h@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/27 00:00:00 by mahajj-h          #+#    #+#             */
/*   Updated: 2025/07/27 00:00:00 by mahajj-h         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

static int	process_export_arg(char *arg_copy, char **name, char **value,
		char ***env_copy)
{
	if (parse_export_arg(arg_copy, name, value))
	{
		free(arg_copy);
		return (1);
	}
	remove_quotes(value);
	if (set_environment_var(*name, *value, env_copy))
	{
		free(arg_copy);
		return (1);
	}
	free(arg_copy);
	return (0);
}

static int	process_single_export_arg(char **argv, int i, char ***env_copy)
{
	char	*arg_copy;
	char	*equals;
	char	*name;
	char	*value;

	arg_copy = ft_strdup(argv[i]);
	if (! arg_copy)
		return (1);
	equals = ft_strchr(arg_copy, '=');
	if (! equals)
	{
		free(arg_copy);
		return (0);
	}
	if (process_export_arg(arg_copy, &name, &value, env_copy))
		return (1);
	return (0);
}

static int	builtin_export(char **argv, char ***env_copy)
{
	int	i;

	if (! argv[1])
	{
		print_sorted_env_vars(*env_copy);
		return (0);
	}
	i = 1;
	while (argv[i])
	{
		if (process_single_export_arg(argv, i, env_copy))
			return (1);
		i++;
	}
	return (0);
}

static int	builtin_unset(char **argv, char ***env_copy)
{
	int	i;

	i = 1;
	while (argv[i])
	{
		if (ft_unsetenv(argv[i], env_copy) != 0)
		{
			perror("unset");
			return (1);
		}
		i++;
	}
	return (0);
}

int	handle_builtin(char **argv, char ***env_copy)
{
	if (! argv[0])
		return (1);
	if (! ft_strcmp(argv[0], "echo"))
		return (builtin_echo(argv));
	if (! ft_strcmp(argv[0], "cd"))
		return (builtin_cd(argv, env_copy));
	if (! ft_strcmp(argv[0], "pwd"))
		return (builtin_pwd(argv));
	if (! ft_strcmp(argv[0], "export"))
		return (builtin_export(argv, env_copy));
	if (! ft_strcmp(argv[0], "unset"))
		return (builtin_unset(argv, env_copy));
	if (! ft_strcmp(argv[0], "env"))
		return (builtin_env(argv, env_copy));
	if (! ft_strcmp(argv[0], "exit"))
		return (builtin_exit(argv));
	return (1);
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   builtin_cd_helper.c                                :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mahajj-h <mahajj-h@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/27 00:00:00 by mahajj-h          #+#    #+#             */
/*   Updated: 2025/07/27 00:00:00 by mahajj-h         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

char	*get_current_directory(void)
{
	char	cwd[1024];

	if (! getcwd(cwd, sizeof(cwd)))
	{
		print_cd_getcwd_failed();
		return (NULL);
	}
	return (ft_strdup(cwd));
}

int	handle_cd_no_args(char *old_pwd, char ***env_copy)
{
	if (cd_to_home(*env_copy) != 0)
	{
		free(old_pwd);
		return (1);
	}
	return (0);
}

int	handle_cd_with_args(char **argv, char *old_pwd)
{
	if (argv[2])
	{
		print_cd_too_many_args();
		free(old_pwd);
		return (1);
	}
	if (cd_to_path(argv[1]) != 0)
	{
		free(old_pwd);
		return (1);
	}
	return (0);
}

int	update_pwd_and_cleanup(char *old_pwd, char ***env_copy)
{
	char	*new_pwd;

	new_pwd = get_current_directory();
	if (! new_pwd)
	{
		free(old_pwd);
		return (1);
	}
	update_pwd_variables(old_pwd, new_pwd, env_copy);
	free(old_pwd);
	free(new_pwd);
	return (0);
}

int	builtin_cd(char **argv, char ***env_copy)
{
	char	*old_pwd;

	old_pwd = get_current_directory();
	if (! old_pwd)
		return (1);
	if (! argv[1])
	{
		if (handle_cd_no_args(old_pwd, env_copy))
			return (1);
	}
	else
	{
		if (handle_cd_with_args(argv, old_pwd))
			return (1);
	}
	return (update_pwd_and_cleanup(old_pwd, env_copy));
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   builtin_cd_utils.c                                 :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mahajj-h <mahajj-h@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/27 00:00:00 by mahajj-h          #+#    #+#             */
/*   Updated: 2025/07/27 00:00:00 by mahajj-h         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

int	cd_to_home(char **env_copy)
{
	char	*home;
	int		i;

	i = 0;
	while (env_copy && env_copy[i])
	{
		if (ft_strncmp(env_copy[i], "HOME=", 5) == 0)
		{
			home = env_copy[i] + 5;
			if (chdir(home) != 0)
			{
				print_cd_error(home, strerror(errno));
				return (1);
			}
			return (0);
		}
		i++;
	}
	print_cd_home_not_set();
	return (1);
}

int	cd_to_path(char *path)
{
	if (chdir(path) != 0)
	{
		print_cd_error(path, strerror(errno));
		return (1);
	}
	return (0);
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   builtin_echo_helper.c                              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mahajj-h <mahajj-h@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/27 00:00:00 by mahajj-h          #+#    #+#             */
/*   Updated: 2025/07/27 00:00:00 by mahajj-h         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

int	check_n_flag(char *arg)
{
	int	j;

	if (arg[0] != '-' || arg[1] != 'n')
		return (0);
	j = 2;
	while (arg[j] == 'n')
		j++;
	return (arg[j] == '\0');
}

int	process_n_flags(char **argv, int *i)
{
	int	print_newline;

	print_newline = 1;
	while (argv[*i] && check_n_flag(argv[*i]))
	{
		print_newline = 0;
		(*i)++;
	}
	return (print_newline);
}

void	print_arguments(char **argv, int start_index)
{
	int	i;

	i = start_index;
	while (argv[i])
	{
		ft_putstr_fd(argv[i], STDOUT_FILENO);
		if (argv[i + 1])
			ft_putstr_fd(" ", STDOUT_FILENO);
		i++;
	}
}

int	builtin_echo(char **argv)
{
	int	i;
	int	print_newline;

	i = 1;
	print_newline = process_n_flags(argv, &i);
	print_arguments(argv, i);
	if (print_newline)
		ft_putstr_fd("\n", STDOUT_FILENO);
	return (0);
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   builtin_exit_helper.c                              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mahajj-h <mahajj-h@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/27 00:00:00 by mahajj-h          #+#    #+#             */
/*   Updated: 2025/07/27 00:00:00 by mahajj-h         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

int	validate_numeric_arg(char *arg)
{
	int	i;

	i = 0;
	if (arg[i] == '-' || arg[i] == '+')
		i++;
	while (arg[i])
	{
		if (! ft_isdigit(arg[i]))
		{
			print_exit_numeric_arg(arg);
			return (0);
		}
		i++;
	}
	return (1);
}

int	check_too_many_args(char **argv)
{
	if (argv[2])
	{
		print_exit_too_many_args();
		return (1);
	}
	return (0);
}

int	process_exit_arg(char **argv)
{
	if (! argv[1])
		return (0);
	if (! validate_numeric_arg(argv[1]))
		clean_exit(255);
	if (check_too_many_args(argv))
		return (1);
	return (ft_atoi(argv[1]));
}

int	builtin_exit(char **argv)
{
	int	status;

	ft_putstr_fd("exit\n", STDOUT_FILENO);
	status = process_exit_arg(argv);
	clean_exit(status);
	return (0);
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   builtin_export_helper.c                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mahajj-h <mahajj-h@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/27 00:00:00 by mahajj-h          #+#    #+#             */
/*   Updated: 2025/07/27 00:00:00 by mahajj-h         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

int	parse_export_arg(char *arg, char **name, char **value)
{
	char	*equals;

	equals = ft_strchr(arg, '=');
	if (! equals)
	{
		print_export_invalid_identifier(arg);
		return (1);
	}
	*name = arg;
	*equals = '\0';
	*value = equals + 1;
	return (0);
}

void	remove_quotes(char **value)
{
	if (**value == '"' && (*value)[ft_strlen(*value) - 1] == '"')
	{
		(*value)++;
		(*value)[ft_strlen(*value) - 1] = '\0';
	}
	else if (**value == '\'' && (*value)[ft_strlen(*value) - 1] == '\'')
	{
		(*value)++;
		(*value)[ft_strlen(*value) - 1] = '\0';
	}
}

void	format_export_output(char *env_var)
{
	char	*equals;
	char	*name;
	char	*value;

	equals = ft_strchr(env_var, '=');
	if (! equals)
	{
		ft_putstr_fd(env_var, STDOUT_FILENO);
		return ;
	}
	*equals = '\0';
	name = env_var;
	value = equals + 1;
	ft_putstr_fd(name, STDOUT_FILENO);
	ft_putstr_fd("=\"", STDOUT_FILENO);
	ft_putstr_fd(value, STDOUT_FILENO);
	ft_putstr_fd("\"", STDOUT_FILENO);
	*equals = '=';
}

int	set_environment_var(char *name, char *value, char ***env_copy)
{
	if (ft_setenv(name, value, 1, env_copy) != 0)
	{
		print_export_error(strerror(errno));
		return (1);
	}
	return (0);
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   builtin_helper.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mahajj-h <mahajj-h@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/27 00:00:00 by mahajj-h          #+#    #+#             */
/*   Updated: 2025/07/27 00:00:00 by mahajj-h         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

static char	**copy_env_to_sorted_array(char **env_copy, int count)
{
	char	**sorted_env;
	int		i;

	sorted_env = malloc((count + 1) * sizeof(char *));
	if (! sorted_env)
		return (NULL);
	i = 0;
	while (env_copy && env_copy[i])
	{
		sorted_env[i] = ft_strdup(env_copy[i]);
		i++;
	}
	sorted_env[i] = NULL;
	return (sorted_env);
}

static void	sort_env_array(char **sorted_env)
{
	int		i;
	int		j;
	char	*temp;

	i = 0;
	while (sorted_env[i])
	{
		j = i + 1;
		while (sorted_env[j])
		{
			if (ft_strcmp(sorted_env[i], sorted_env[j]) > 0)
			{
				temp = sorted_env[i];
				sorted_env[i] = sorted_env[j];
				sorted_env[j] = temp;
			}
			j++;
		}
		i++;
	}
}

static void	print_sorted_array(char **sorted_env)
{
	int		i;

	i = 0;
	while (sorted_env[i])
	{
		ft_putstr_fd("declare -x ", STDOUT_FILENO);
		format_export_output(sorted_env[i]);
		ft_putstr_fd("\n", STDOUT_FILENO);
		i++;
	}
}

static void	free_sorted_array(char **sorted_env)
{
	int		i;

	i = 0;
	while (sorted_env[i])
	{
		free(sorted_env[i]);
		i++;
	}
	free(sorted_env);
}

void	print_sorted_env_vars(char **env_copy)
{
	int		count;
	char	**sorted_env;

	count = 0;
	while (env_copy && env_copy[count])
		count++;
	sorted_env = copy_env_to_sorted_array(env_copy, count);
	if (! sorted_env)
		return ;
	sort_env_array(sorted_env);
	print_sorted_array(sorted_env);
	free_sorted_array(sorted_env);
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   builtin_helper2.c                                  :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mahajj-h <mahajj-h@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/27 00:00:00 by mahajj-h          #+#    #+#             */
/*   Updated: 2025/07/27 00:00:00 by mahajj-h         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

int	count_env_vars_pwd(char ***env_copy)
{
	int		count;

	count = 0;
	while ((*env_copy)[count])
		count++;
	return (count);
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   builtin_pwd_helper.c                               :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mahajj-h <mahajj-h@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/27 00:00:00 by mahajj-h          #+#    #+#             */
/*   Updated: 2025/07/27 00:00:00 by mahajj-h         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

int	prepare_pwd_variables(t_pwd_prep_params params)
{
	int		count;

	*params.old_pwd_var = create_old_pwd_var(params.old_pwd);
	*params.new_pwd_var = create_new_pwd_var(params.new_pwd);
	if (! *params.old_pwd_var || ! *params.new_pwd_var)
	{
		free(*params.old_pwd_var);
		free(*params.new_pwd_var);
		return (0);
	}
	count = count_env_vars_pwd(params.env_copy);
	*params.new_environ = allocate_new_environ_pwd(params.env_copy, count);
	if (! *params.new_environ)
	{
		free(*params.old_pwd_var);
		free(*params.new_pwd_var);
		return (0);
	}
	return (count);
}

void	update_pwd_variables(char *old_pwd, char *new_pwd, char ***env_copy)
{
	char	**new_environ;
	char	*old_pwd_var;
	char	*new_pwd_var;
	int		count;

	count = prepare_pwd_variables((t_pwd_prep_params){old_pwd, new_pwd,
			env_copy, &old_pwd_var, &new_pwd_var, &new_environ});
	if (count == 0)
		return ;
	copy_and_update_env_vars(env_copy, new_environ, old_pwd_var, new_pwd_var);
	finalize_new_environ_pwd(new_environ, count, old_pwd_var, new_pwd_var);
	free(*env_copy);
	*env_copy = new_environ;
}

int	builtin_env(char **argv, char ***env_copy)
{
	int			i;

	(void)argv;
	i = 0;
	while ((*env_copy)[i])
	{
		ft_putstr_fd((*env_copy)[i], STDOUT_FILENO);
		ft_putstr_fd("\n", STDOUT_FILENO);
		i++;
	}
	return (0);
}

int	builtin_pwd(char **argv)
{
	char	cwd[1024];

	(void)argv;
	if (! getcwd(cwd, sizeof(cwd)))
	{
		perror("pwd");
		return (1);
	}
	ft_putstr_fd(cwd, STDOUT_FILENO);
	ft_putstr_fd("\n", STDOUT_FILENO);
	return (0);
}

void	finalize_new_environ_pwd(char **new_environ, int count,
		char *old_pwd_var, char *new_pwd_var)
{
	if (count == 0)
	{
		new_environ[0] = old_pwd_var;
		new_environ[1] = new_pwd_var;
		new_environ[2] = NULL;
	}
	else
	{
		new_environ[count] = NULL;
	}
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   builtin_utils.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mahajj-h <mahajj-h@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/27 00:00:00 by mahajj-h          #+#    #+#             */
/*   Updated: 2025/07/27 00:00:00 by mahajj-h         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

int	is_builtin(char *cmd)
{
	if (! ft_strcmp(cmd, "echo"))
		return (1);
	if (! ft_strcmp(cmd, "cd"))
		return (1);
	if (! ft_strcmp(cmd, "pwd"))
		return (1);
	if (! ft_strcmp(cmd, "export"))
		return (1);
	if (! ft_strcmp(cmd, "unset"))
		return (1);
	if (! ft_strcmp(cmd, "env"))
		return (1);
	if (! ft_strcmp(cmd, "exit"))
		return (1);
	return (0);
}

char	*create_old_pwd_var(char *old_pwd)
{
	char	*old_pwd_var;

	old_pwd_var = malloc(ft_strlen("OLDPWD") + ft_strlen(old_pwd) + 2);
	if (! old_pwd_var)
		return (NULL);
	ft_strcpy(old_pwd_var, "OLDPWD=");
	ft_strlcat(old_pwd_var, old_pwd,
		ft_strlen("OLDPWD") + ft_strlen(old_pwd) + 2);
	return (old_pwd_var);
}

char	**allocate_new_environ_pwd(char ***env_copy, int count)
{
	char	**new_environ;

	(void)env_copy;
	new_environ = malloc((count + 3) * sizeof(char *));
	if (! new_environ)
		return (NULL);
	return (new_environ);
}

char	*create_new_pwd_var(char *new_pwd)
{
	char	*new_pwd_var;

	new_pwd_var = malloc(ft_strlen("PWD") + ft_strlen(new_pwd) + 2);
	if (! new_pwd_var)
		return (NULL);
	ft_strcpy(new_pwd_var, "PWD=");
	ft_strlcat(new_pwd_var, new_pwd,
		ft_strlen("PWD") + ft_strlen(new_pwd) + 2);
	return (new_pwd_var);
}

void	copy_and_update_env_vars(char ***env_copy, char **new_environ,
		char *old_pwd_var, char *new_pwd_var)
{
	int		i;

	i = 0;
	while ((*env_copy)[i])
	{
		if (ft_strncmp((*env_copy)[i], "OLDPWD=", 7) == 0)
		{
			free((*env_copy)[i]);
			new_environ[i] = old_pwd_var;
		}
		else if (ft_strncmp((*env_copy)[i], "PWD=", 4) == 0)
		{
			free((*env_copy)[i]);
			new_environ[i] = new_pwd_var;
		}
		else
		{
			new_environ[i] = (*env_copy)[i];
		}
		i++;
	}
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   constructs.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mahajj-h <mahajj-h@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/27 00:00:00 by mahajj-h          #+#    #+#             */
/*   Updated: 2025/07/27 00:00:00 by mahajj-h         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

struct s_cmd	*execcmd(void)
{
	struct s_execcmd	*cmd;

	cmd = malloc(sizeof(*cmd));
	if (! cmd)
		return (NULL);
	ft_memset(cmd, 0, sizeof(*cmd));
	cmd->type = EXEC;
	return ((struct s_cmd *)cmd);
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   constructs_helper.c                                :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mahajj-h <mahajj-h@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/27 00:00:00 by mahajj-h          #+#    #+#             */
/*   Updated: 2025/07/27 00:00:00 by mahajj-h         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

struct s_cmd	*redircmd(struct s_cmd *subcmd, char *file,
		char *efile, t_redir_params params)
{
	struct s_redircmd	*cmd;

	cmd = malloc(sizeof(*cmd));
	if (! cmd)
	{
		free_cmd(subcmd);
		free(file);
		free(efile);
		return (NULL);
	}
	ft_memset(cmd, 0, sizeof(*cmd));
	cmd->type = REDIR;
	cmd->cmd = subcmd;
	cmd->file = file;
	cmd->efile = efile;
	cmd->mode = params.mode;
	cmd->fd = params.fd;
	return ((struct s_cmd *)cmd);
}

struct s_cmd	*pipecmd(struct s_cmd *left, struct s_cmd *right)
{
	struct s_pipecmd	*cmd;

	cmd = malloc(sizeof(*cmd));
	if (! cmd)
	{
		free_cmd(left);
		free_cmd(right);
		return (NULL);
	}
	ft_memset(cmd, 0, sizeof(*cmd));
	cmd->type = PIPE;
	cmd->left = left;
	cmd->right = right;
	return ((struct s_cmd *)cmd);
}

struct s_cmd	*backcmd(struct s_cmd *subcmd)
{
	struct s_backcmd	*cmd;

	cmd = malloc(sizeof(*cmd));
	if (! cmd)
	{
		free_cmd(subcmd);
		return (NULL);
	}
	ft_memset(cmd, 0, sizeof(*cmd));
	cmd->type = BACK;
	cmd->cmd = subcmd;
	return ((struct s_cmd *)cmd);
}

struct s_cmd	*heredoccmd(struct s_cmd *subcmd, char *delimiter,
	char *content)
{
	struct s_heredoccmd	*cmd;

	cmd = malloc(sizeof(*cmd));
	if (! cmd)
	{
		free(delimiter);
		free(content);
		return (NULL);
	}
	ft_memset(cmd, 0, sizeof(*cmd));
	cmd->type = HEREDOC;
	cmd->cmd = subcmd;
	cmd->delimiter = delimiter;
	cmd->content = content;
	cmd->fd = 0;
	return ((struct s_cmd *)cmd);
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   env.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mahajj-h <mahajj-h@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/27 00:00:00 by mahajj-h          #+#    #+#             */
/*   Updated: 2025/07/27 00:00:00 by mahajj-h         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

static int	g_exit_status = 0;

void	set_exit_status(int status)
{
	g_exit_status = status;
}

int	get_exit_status(void)
{
	return (g_exit_status);
}

static char	*finalize_result(char *result, size_t j)
{
	char	*final;

	result[j] = '\0';
	final = ft_realloc(result, j + 1);
	if (final)
		return (final);
	else
		return (result);
}

char	*expand_variables(const char *str, size_t len, char **env_copy)
{
	char	*result;
	size_t	i;
	size_t	j;
	size_t	alloc_size;

	if (! str)
		return (ft_strdup(""));
	i = 0;
	j = 0;
	result = init_result_buffer(len, &alloc_size);
	if (! result)
		return (NULL);
	while (i < len)
	{
		if (process_character((t_process_char_params){str, len, &i,
				&result, &j, &alloc_size, env_copy}))
			return (NULL);
	}
	return (finalize_result(result, j));
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   env_helper1.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mahajj-h <mahajj-h@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/27 00:00:00 by mahajj-h          #+#    #+#             */
/*   Updated: 2025/07/27 00:00:00 by mahajj-h         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

size_t	get_var_name_len(const char *str)
{
	size_t	len;

	len = 0;
	if (*str == '?')
		return (1);
	while (str[len] && (isalnum(str[len]) || str[len] == '_'))
		len++;
	return (len);
}

char	*get_env_value(const char *name, size_t name_len, char **env_copy)
{
	char	*temp;

	if (name_len == 1 && *name == '?')
		return (handle_exit_status_var());
	temp = malloc(name_len + 1);
	if (! temp)
		return (NULL);
	ft_strncpy(temp, name, name_len);
	temp[name_len] = '\0';
	if (! env_copy)
	{
		free(temp);
		return (NULL);
	}
	return (search_env_variable(name, name_len, env_copy, temp));
}

int	handle_env_variable(t_env_var_params params, char **env_copy)
{
	size_t	var_name_len;
	char	*env_value;

	(*params.i)++;
	var_name_len = get_var_name_len(params.str + *params.i);
	env_value = get_env_value(params.str + *params.i, var_name_len, env_copy);
	if (env_value)
	{
		if (handle_env_value_found(params, env_value, var_name_len, env_copy))
			return (1);
	}
	else
	{
		if (handle_env_value_not_found(params, var_name_len))
			return (1);
	}
	*params.i += var_name_len;
	return (0);
}

int	handle_regular_char(t_regular_char_params params)
{
	*params.result = resize_for_char(*params.result,
			params.alloc_size, *params.j);
	if (! *params.result)
		return (1);
	(*params.result)[(*params.j)++] = params.str[(*params.i)++];
	return (0);
}

int	process_character(t_process_char_params params)
{
	if (is_variable_char(params.str, *params.i, params.len))
	{
		if (handle_env_variable((t_env_var_params){params.str, params.i,
				params.result, params.j, params.alloc_size, params.env_copy},
			params.env_copy))
			return (1);
	}
	else
	{
		if (handle_regular_char((t_regular_char_params){params.str, params.i,
				params.result, params.j, params.alloc_size}))
			return (1);
	}
	return (0);
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   env_helper1_helper.c                              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mahajj-h <mahajj-h@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/27 00:00:00 by mahajj-h          #+#    #+#             */
/*   Updated: 2025/07/27 00:00:00 by mahajj-h         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

char	*init_result_buffer(size_t len, size_t *alloc_size)
{
	char	*result;

	*alloc_size = len * 2;
	result = malloc(*alloc_size);
	if (!result)
		return (NULL);
	return (result);
}

char	*resize_for_env_value(char *result, size_t *alloc_size,
	size_t j, size_t value_len)
{
	char	*new_result;

	if (j + value_len >= *alloc_size)
	{
		*alloc_size = (j + value_len) * 2;
		new_result = ft_realloc(result, *alloc_size);
		if (!new_result)
		{
			free(result);
			return (NULL);
		}
		result = new_result;
	}
	return (result);
}

char	*resize_for_char(char *result, size_t *alloc_size, size_t j)
{
	char	*new_result;

	if (j + 1 >= *alloc_size)
	{
		*alloc_size *= 2;
		new_result = ft_realloc(result, *alloc_size);
		if (!new_result)
		{
			free(result);
			return (NULL);
		}
		result = new_result;
	}
	return (result);
}

int	is_variable_char(const char *str, size_t i, size_t len)
{
	if (str[i] == '$' && i + 1 < len
		&& (isalnum(str[i + 1]) || str[i + 1] == '_' || str[i + 1] == '?'))
		return (1);
	return (0);
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   env_helper2.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mahajj-h <mahajj-h@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/27 00:00:00 by mahajj-h          #+#    #+#             */
/*   Updated: 2025/07/27 00:00:00 by mahajj-h         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

char	*handle_exit_status_var(void)
{
	char	*status_str;

	status_str = ft_itoa(get_exit_status());
	if (! status_str)
		return (ft_strdup("0"));
	return (status_str);
}

char	*search_env_variable(const char *name, size_t name_len,
		char **env_copy, char *temp)
{
	char	*value;
	int		i;

	(void)name;
	i = 0;
	while (env_copy[i])
	{
		if (ft_strncmp(env_copy[i], temp, name_len) == 0
			&& env_copy[i][name_len] == '=')
		{
			value = ft_strdup(env_copy[i] + name_len + 1);
			free(temp);
			return (value);
		}
		i++;
	}
	free(temp);
	return (NULL);
}

int	handle_env_value_found(t_env_var_params params, char *env_value,
		size_t var_name_len, char **env_copy)
{
	size_t	value_len;

	(void)env_copy;
	(void)var_name_len;
	value_len = ft_strlen(env_value);
	*params.result = resize_for_env_value(*params.result,
			params.alloc_size, *params.j, value_len);
	if (! *params.result)
	{
		free(env_value);
		return (1);
	}
	ft_strcpy(*params.result + *params.j, env_value);
	*params.j += value_len;
	free(env_value);
	return (0);
}

int	handle_env_value_not_found(t_env_var_params params,
		size_t var_name_len)
{
	*params.result = resize_for_char(*params.result,
			params.alloc_size, *params.j);
	if (! *params.result)
		return (1);
	(*params.result)[(*params.j)++] = '$';
	*params.result = resize_for_env_value(*params.result,
			params.alloc_size, *params.j, var_name_len);
	if (! *params.result)
		return (1);
	ft_strncpy(*params.result + *params.j, params.str + *params.i,
		var_name_len);
	*params.j += var_name_len;
	return (0);
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   heredoc.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mahajj-h <mahajj-h@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/27 00:00:00 by mahajj-h          #+#    #+#             */
/*   Updated: 2025/07/27 00:00:00 by mahajj-h         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

static char	*process_heredoc_line(char *line, char **env_copy, int is_quoted)
{
	char	*expanded_line;

	expanded_line = line;
	if (! is_quoted)
	{
		expanded_line = expand_variables(line, ft_strlen(line), env_copy);
		if (! expanded_line)
		{
			free(line);
			return (NULL);
		}
	}
	return (expanded_line);
}

static char	*handle_heredoc_line(char *content, char *line, char **env_copy,
		int is_quoted)
{
	char	*expanded_line;
	char	*new_content;

	expanded_line = process_heredoc_line(line, env_copy, is_quoted);
	if (! expanded_line)
		return (NULL);
	new_content = append_line_to_content(content, expanded_line);
	free(content);
	free(line);
	if (expanded_line != line)
		free(expanded_line);
	return (new_content);
}

static char	*process_heredoc_loop(char *content, char *stripped_delimiter,
		char **env_copy, int is_quoted)
{
	char	*line;
	char	*new_content;

	while (1)
	{
		write(STDOUT_FILENO, "> ", 2);
		line = read_line_without_history();
		if (! line)
		{
			print_heredoc_eof_warning(stripped_delimiter);
			break ;
		}
		if (check_delimiter_match(line, stripped_delimiter))
		{
			free(line);
			break ;
		}
		new_content = handle_heredoc_line(content, line, env_copy, is_quoted);
		if (! new_content)
			return (NULL);
		content = new_content;
	}
	return (content);
}

char	*read_heredoc_content(char *delimiter, char **env_copy, int is_quoted)
{
	char	*stripped_delimiter;
	char	*content;

	stripped_delimiter = ft_strdup(delimiter);
	content = ft_strdup("");
	if (! content)
	{
		free(stripped_delimiter);
		return (NULL);
	}
	setup_heredoc_signals();
	content = process_heredoc_loop(content,
			stripped_delimiter, env_copy, is_quoted);
	if (! content)
	{
		free(stripped_delimiter);
		return (NULL);
	}
	init_signals();
	free(stripped_delimiter);
	return (content);
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   heredoc_helper.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mahajj-h <mahajj-h@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/27 00:00:00 by mahajj-h          #+#    #+#             */
/*   Updated: 2025/07/27 00:00:00 by mahajj-h         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

void	setup_heredoc_signals(void)
{
	struct sigaction	sa_int;

	sa_int.sa_handler = heredoc_sigint_handler;
	sigemptyset(&sa_int.sa_mask);
	sa_int.sa_flags = SA_RESTART;
	sigaction(SIGINT, &sa_int, NULL);
}

void	heredoc_sigint_handler(int signo)
{
	(void)signo;
	write(STDERR_FILENO, "\n", 1);
	clean_exit(130);
}

char	*read_line_without_history(void)
{
	char	buffer[4096];
	char	*line;
	int		i;
	int		c;

	i = 0;
	while (i < 4095)
	{
		c = getchar();
		if (c == EOF)
		{
			if (i == 0)
				return (NULL);
			break ;
		}
		if (c == '\n')
			break ;
		buffer[i++] = (char)c;
	}
	buffer[i] = '\0';
	line = ft_strdup(buffer);
	return (line);
}

char	*append_line_to_content(char *content, char *line)
{
	size_t	content_len;
	size_t	line_len;
	char	*new_content;

	content_len = ft_strlen(content);
	line_len = ft_strlen(line);
	new_content = malloc(content_len + line_len + 2);
	if (! new_content)
		return (NULL);
	ft_strcpy(new_content, content);
	ft_strcpy(new_content + content_len, line);
	new_content[content_len + line_len] = '\n';
	new_content[content_len + line_len + 1] = '\0';
	return (new_content);
}

int	check_delimiter_match(char *line, char *stripped_delimiter)
{
	size_t	delimiter_len;

	delimiter_len = ft_strlen(stripped_delimiter);
	return (ft_strlen(line) == delimiter_len
		&& ft_strncmp(line, stripped_delimiter, delimiter_len) == 0);
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   main.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mahajj-h <mahajj-h@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/27 00:00:00 by mahajj-h          #+#    #+#             */
/*   Updated: 2025/07/27 00:00:00 by mahajj-h         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

static int	process_command_line(char *line, struct s_cmd **cmd,
		char ***environ_copy)
{
	if (handle_tokenize(line, cmd, *environ_copy))
		return (1);
	if (*cmd)
	{
		if (process_builtin_command(*cmd, line, environ_copy))
			return (1);
		execute_external_command(*cmd, *environ_copy);
	}
	return (0);
}

int	main(int argc, char **argv, char **envp)
{
	char			*line;
	struct s_cmd	*cmd;
	char			**environ_copy;

	if (validate_arguments(argc, argv))
		return (1);
	if (initialize_environment(envp, &environ_copy))
		return (1);
	setup_signals_interactive();
	rl_catch_signals = 0;
	while (1)
	{
		init_signals();
		if (handle_line_input(&line))
			continue ;
		if (! line || ft_strlen(line) == 0 || is_only_whitespace(line))
			continue ;
		if (process_command_line(line, &cmd, &environ_copy))
			continue ;
		if (line)
			free(line);
	}
	clean_exit(0);
	return (0);
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   main_helper1.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mahajj-h <mahajj-h@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/27 00:00:00 by mahajj-h          #+#    #+#             */
/*   Updated: 2025/07/27 00:00:00 by mahajj-h         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

int	handle_eof(char *buf, size_t len)
{
	if (len == 0)
	{
		if (isatty(STDIN_FILENO))
			ft_putstr_fd("exit\n", STDOUT_FILENO);
		free(buf);
		clean_exit(0);
	}
	clearerr(stdin);
	return (1);
}

void	init_signals(void)
{
}

int	handle_line_input(char **line)
{
	*line = readline("minishell$ ");
	if (! *line)
	{
		ft_putstr_fd("exit\n", STDOUT_FILENO);
		clean_exit(0);
	}
	if (ft_strlen(*line) > 0)
		add_history(*line);
	return (0);
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   main_helper2.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mahajj-h <mahajj-h@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/27 00:00:00 by mahajj-h          #+#    #+#             */
/*   Updated: 2025/07/27 00:00:00 by mahajj-h         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

int	handle_tokenize(char *line, struct s_cmd **cmd, char **env_copy)
{
	*cmd = tokenize(line, env_copy);
	if (! *cmd)
	{
		free(line);
		return (1);
	}
	return (0);
}

void	execute_cmd(struct s_cmd *cmd, char **env_copy)
{
	int		status;
	pid_t	pid;

	pid = fork();
	if (pid < 0)
	{
		perror("fork failed");
		set_exit_status(1);
		return ;
	}
	if (pid == 0)
	{
		runcmd(cmd, env_copy);
		clean_exit(get_exit_status());
	}
	waitpid(pid, &status, 0);
	handle_child_status(status);
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   main_helper3.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mahajj-h <mahajj-h@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/27 00:00:00 by mahajj-h          #+#    #+#             */
/*   Updated: 2025/07/27 00:00:00 by mahajj-h         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

void	expand_builtin_args(struct s_execcmd *ecmd, char **env_copy)
{
	int		i;
	char	*original;

	i = 0;
	while (ecmd->av[i])
	{
		original = ecmd->av[i];
		ecmd->av[i] = expand_variables(original, ft_strlen(original),
				env_copy);
		free(original);
		i++;
	}
}

int	handle_builtin_cmd(struct s_cmd *cmd, char *line, char ***env_copy)
{
	struct s_execcmd	*ecmd;
	int					status;

	(void)line;
	if (cmd->type == EXEC)
	{
		ecmd = (struct s_execcmd *)cmd;
		if (ecmd->av[0] && is_builtin(ecmd->av[0]))
		{
			status = handle_builtin(ecmd->av, env_copy);
			set_exit_status(status);
			return (1);
		}
	}
	return (0);
}

void	handle_child_status(int status)
{
	if (WIFSIGNALED(status))
	{
		if (WTERMSIG(status) == SIGINT)
			set_exit_status(130);
		else if (WTERMSIG(status) == SIGQUIT)
			set_exit_status(131);
		else
			set_exit_status(128 + WTERMSIG(status));
	}
	else
	{
		set_exit_status(WEXITSTATUS(status));
	}
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   main_helper4.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mahajj-h <mahajj-h@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/27 00:00:00 by mahajj-h          #+#    #+#             */
/*   Updated: 2025/07/27 00:00:00 by mahajj-h         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

void	sigint_handler_interactive(int signo)
{
	(void)signo;
	write(STDOUT_FILENO, "\n", 1);
	rl_on_new_line();
	rl_replace_line("", 0);
	rl_redisplay();
	set_exit_status(130);
}

void	sigquit_handler_interactive(int signo)
{
	(void)signo;
}

void	sigint_handler_noninteractive(int signo)
{
	(void)signo;
	write(STDOUT_FILENO, "\n", 1);
}

void	sigquit_handler_noninteractive(int signo)
{
	(void)signo;
}

void	setup_signals_interactive(void)
{
	struct sigaction	sa_int;
	struct sigaction	sa_quit;

	sa_int.sa_handler = sigint_handler_interactive;
	sigemptyset(&sa_int.sa_mask);
	sa_int.sa_flags = SA_RESTART;
	sigaction(SIGINT, &sa_int, NULL);
	sa_quit.sa_handler = sigquit_handler_interactive;
	sigemptyset(&sa_quit.sa_mask);
	sa_quit.sa_flags = SA_RESTART;
	sigaction(SIGQUIT, &sa_quit, NULL);
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   main_helper5.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mahajj-h <mahajj-h@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/27 00:00:00 by mahajj-h          #+#    #+#             */
/*   Updated: 2025/07/27 00:00:00 by mahajj-h         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

void	setup_signals_noninteractive(void)
{
	struct sigaction	sa_int;
	struct sigaction	sa_quit;

	sa_int.sa_handler = sigint_handler_noninteractive;
	sigemptyset(&sa_int.sa_mask);
	sa_int.sa_flags = SA_RESTART;
	sigaction(SIGINT, &sa_int, NULL);
	sa_quit.sa_handler = sigquit_handler_noninteractive;
	sigemptyset(&sa_quit.sa_mask);
	sa_quit.sa_flags = SA_RESTART;
	sigaction(SIGQUIT, &sa_quit, NULL);
}

int	validate_arguments(int argc, char **argv)
{
	(void)argv;
	if (argc != 1)
	{
		ft_putstr_fd("Usage: ./minishell\n", STDERR_FILENO);
		return (1);
	}
	return (0);
}

int	initialize_environment(char **envp, char ***environ_copy)
{
	*environ_copy = copy_environ(envp);
	if (! *environ_copy)
	{
		ft_putstr_fd("Failed to copy environment\n", STDERR_FILENO);
		return (1);
	}
	return (0);
}

int	process_builtin_command(struct s_cmd *cmd, char *line,
		char ***environ_copy)
{
	if (handle_builtin_cmd(cmd, line, environ_copy))
	{
		free_cmd(cmd);
		if (line)
			free(line);
		return (1);
	}
	return (0);
}

void	execute_external_command(struct s_cmd *cmd, char **environ_copy)
{
	setup_signals_noninteractive();
	execute_cmd(cmd, environ_copy);
	setup_signals_interactive();
	free_cmd(cmd);
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   memory_management.c                                :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mahajj-h <mahajj-h@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/27 00:00:00 by mahajj-h          #+#    #+#             */
/*   Updated: 2025/07/27 00:00:00 by mahajj-h         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

char	**copy_environ(char **envp)
{
	char	**new_environ;
	int		count;

	if (! envp)
		return (NULL);
	count = count_envp_vars(envp);
	new_environ = malloc((count + 1) * sizeof(char *));
	if (! new_environ)
		return (NULL);
	if (! copy_env_vars(envp, new_environ))
		return (NULL);
	increment_shlvl(&new_environ);
	return (new_environ);
}

void	free_environ_copy(char **environ_copy)
{
	int	i;

	if (! environ_copy)
		return ;
	i = 0;
	while (environ_copy[i])
	{
		if (environ_copy[i])
		{
			free(environ_copy[i]);
			environ_copy[i] = NULL;
		}
		i++;
	}
	free(environ_copy);
}

void	clean_exit(int status)
{
	rl_clear_history();
	exit(status);
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   memory_management_helper2.c                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mahajj-h <mahajj-h@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/27 00:00:00 by mahajj-h          #+#    #+#             */
/*   Updated: 2025/07/27 00:00:00 by mahajj-h         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

int	count_envp_vars(char **envp)
{
	int	count;

	count = 0;
	while (envp[count])
		count++;
	return (count);
}

void	cleanup_on_failure(char **new_environ, int i)
{
	while (i > 0)
	{
		i--;
		free(new_environ[i]);
	}
	free(new_environ);
}

int	copy_env_vars(char **envp, char **new_environ)
{
	int	i;

	i = 0;
	while (envp[i])
	{
		new_environ[i] = ft_strdup(envp[i]);
		if (! new_environ[i])
		{
			cleanup_on_failure(new_environ, i);
			return (0);
		}
		i++;
	}
	new_environ[i] = NULL;
	return (1);
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   memory_management_helper.c                          :+:      :+:    :+:  */
/*                                                    +:+ +:+         +:+     */
/*   By: mahajj-h <mahajj-h@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/27 00:00:00 by mahajj-h          #+#    #+#             */
/*   Updated: 2025/07/27 00:00:00 by mahajj-h         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

void	update_shlvl_value(char ***env_copy, int i, int shlvl_num)
{
	char	*new_shlvl;
	char	*old_value;

	new_shlvl = ft_itoa(shlvl_num);
	if (new_shlvl)
	{
		old_value = (*env_copy)[i];
		(*env_copy)[i] = malloc(ft_strlen("SHLVL=")
				+ ft_strlen(new_shlvl) + 1);
		if ((*env_copy)[i])
		{
			ft_strcpy((*env_copy)[i], "SHLVL=");
			ft_strlcat((*env_copy)[i], new_shlvl,
				ft_strlen("SHLVL=") + ft_strlen(new_shlvl) + 1);
			free(old_value);
		}
		else
		{
			(*env_copy)[i] = old_value;
		}
		free(new_shlvl);
	}
}

void	create_new_shlvl(char ***env_copy)
{
	char	*new_shlvl;

	new_shlvl = ft_itoa(1);
	if (new_shlvl)
	{
		ft_setenv("SHLVL", new_shlvl, 1, env_copy);
		free(new_shlvl);
	}
}

void	increment_shlvl(char ***env_copy)
{
	char	*shlvl_value;
	int		shlvl_num;
	int		i;

	i = 0;
	while ((*env_copy)[i])
	{
		if (ft_strncmp((*env_copy)[i], "SHLVL=", 6) == 0)
		{
			shlvl_value = (*env_copy)[i] + 6;
			shlvl_num = ft_atoi(shlvl_value);
			if (shlvl_num < 0 || shlvl_num >= 1000)
				shlvl_num = 0;
			shlvl_num++;
			update_shlvl_value(env_copy, i, shlvl_num);
			return ;
		}
		i++;
	}
	create_new_shlvl(env_copy);
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parses.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mahajj-h <mahajj-h@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/27 00:00:00 by mahajj-h          #+#    #+#             */
/*   Updated: 2025/07/27 00:00:00 by mahajj-h         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

struct s_cmd	*parse_pipe(char **input_ptr, char *input_end, char **env_copy)
{
	struct s_cmd	*cmd;
	struct s_cmd	*right;

	cmd = parseexec(input_ptr, input_end, env_copy);
	if (! cmd)
		return (NULL);
	if (peek(input_ptr, input_end, "|"))
	{
		gettoken(input_ptr, input_end, NULL, NULL);
		right = parse_pipe(input_ptr, input_end, env_copy);
		if (! right)
		{
			free_cmd(cmd);
			return (NULL);
		}
		cmd = pipecmd(cmd, right);
		if (! cmd)
			return (NULL);
	}
	return (cmd);
}

struct s_cmd	*parse_line(char **input_ptr, char *input_end, char **env_copy)
{
	struct s_cmd	*cmd;

	cmd = parse_pipe(input_ptr, input_end, env_copy);
	if (! cmd)
		return (NULL);
	if (peek(input_ptr, input_end, "&"))
	{
		gettoken(input_ptr, input_end, NULL, NULL);
		cmd = backcmd(cmd);
		if (! cmd)
			return (NULL);
		if (! peek(input_ptr, input_end, "\0"))
		{
			return (parse_line(input_ptr, input_end, env_copy));
		}
	}
	return (cmd);
}

struct s_cmd	*parse_block(char **input_ptr, char *input_end, char **env_copy)
{
	struct s_cmd	*cmd;

	if (! peek(input_ptr, input_end, "("))
	{
		print_missing_paren("(");
		return (NULL);
	}
	gettoken(input_ptr, input_end, NULL, NULL);
	cmd = parse_line(input_ptr, input_end, env_copy);
	if (! cmd)
		return (NULL);
	if (! peek(input_ptr, input_end, ")"))
	{
		print_missing_paren(")");
		free_cmd(cmd);
		return (NULL);
	}
	gettoken(input_ptr, input_end, NULL, NULL);
	return (cmd);
}

struct s_cmd	*parseexec(char **input_ptr, char *input_end, char **env_copy)
{
	struct s_execcmd	*cmd;
	struct s_cmd		*ret;
	int					argc;

	argc = 0;
	if (peek(input_ptr, input_end, "("))
		return (parse_block(input_ptr, input_end, env_copy));
	ret = init_exec_cmd();
	if (! ret)
		return (NULL);
	cmd = (struct s_execcmd *)ret;
	ret = process_arguments_and_redirs(ret,
			(t_process_args_params){cmd, input_ptr, input_end, &argc},
			env_copy);
	if (! ret)
		return (NULL);
	finalize_exec_cmd(cmd, argc);
	return (ret);
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parses_helper10.c                                  :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mahajj-h <mahajj-h@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/27 00:00:00 by mahajj-h          #+#    #+#             */
/*   Updated: 2025/07/27 00:00:00 by mahajj-h         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

int	handle_redirection_token(t_redir_token_params params)
{
	int					filename_tok;
	t_redir_file_params	file_params;

	filename_tok = gettoken(params.params.input_ptr,
			params.params.input_end, params.q, params.eq);
	if (filename_tok != 'a')
		return (validate_filename_token(filename_tok, params.ret,
				params.params));
	file_params.ret = params.ret;
	file_params.params = params.params;
	file_params.env_copy = params.env_copy;
	file_params.tok = params.tok;
	file_params.q = params.q;
	file_params.eq = params.eq;
	return (process_redirection_file(file_params));
}

void	skip_to_quote_end(char **temp_ptr, char *temp_end, char quote_char)
{
	(*temp_ptr)++;
	while (*temp_ptr < temp_end && **temp_ptr != quote_char)
		(*temp_ptr)++;
}

int	count_consecutive_quotes(char **q, char **eq)
{
	char	*temp_ptr;
	char	*temp_end;
	int		count;

	temp_ptr = *q;
	temp_end = *eq;
	count = 0;
	while (temp_ptr < temp_end)
	{
		if (*temp_ptr == '"' || *temp_ptr == '\'')
		{
			skip_to_quote_end(&temp_ptr, temp_end, *temp_ptr);
			count++;
		}
		else
		{
			temp_ptr++;
		}
	}
	return (count);
}

int	process_consecutive_quotes(t_consecutive_quotes_params params)
{
	char	*concatenated;

	concatenated = concatenate_quoted_strings(params.params.input_ptr,
			params.params.input_end, params.env_copy);
	if (! concatenated)
	{
		free_cmd(*params.ret);
		return (1);
	}
	add_argument(params.params.cmd, concatenated, params.params.argc);
	*params.q = *params.params.input_ptr;
	*params.eq = *params.params.input_ptr;
	return (0);
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parses_helper1.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mahajj-h <mahajj-h@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/27 00:00:00 by mahajj-h          #+#    #+#             */
/*   Updated: 2025/07/27 00:00:00 by mahajj-h         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

char	*init_output_buffer(size_t len)
{
	char	*output;

	output = malloc(len + 1);
	if (!output)
		return (NULL);
	return (output);
}

char	*process_escaped(const char *input, size_t len)
{
	char	*output;
	size_t	i;

	output = malloc(len + 1);
	if (!output)
		return (NULL);
	i = 0;
	while (i < len)
	{
		output[i] = input[i];
		i++;
	}
	output[i] = '\0';
	return (output);
}

int	get_redir_token(char **input_ptr, char *input_end,
			char **q, char **eq)
{
	int	tok;

	tok = gettoken(input_ptr, input_end, NULL, NULL);
	if (gettoken(input_ptr, input_end, q, eq) != 'a')
	{
		print_missing_file_name();
		return (0);
	}
	return (tok);
}

char	*process_filename(char *q, char *eq, char **env_copy)
{
	size_t	len;
	char	*processed;
	char	*expanded;

	len = eq - q;
	processed = process_escaped(q, len);
	if (!processed)
	{
		print_malloc_failed();
		return (NULL);
	}
	expanded = expand_variables(processed, ft_strlen(processed), env_copy);
	free(processed);
	if (!expanded)
	{
		print_malloc_failed();
		return (NULL);
	}
	return (expanded);
}

struct s_cmd	*handle_redir_token(struct s_cmd *cmd, int tok, char *file)
{
	if (tok == '<')
		return (apply_input_redir(cmd, file));
	else if (tok == '>')
		return (apply_output_redir(cmd, file));
	else if (tok == '+')
		return (apply_append_redir(cmd, file));
	else if (tok == 'H')
		return (handle_heredoc_token(cmd, file, NULL, 0));
	return (cmd);
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parses_helper2.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mahajj-h <mahajj-h@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/27 00:00:00 by mahajj-h          #+#    #+#             */
/*   Updated: 2025/07/27 00:00:00 by mahajj-h         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

char	get_escape_char(char c)
{
	if (c == 'n')
		return ('\n');
	else if (c == 't')
		return ('\t');
	else if (c == 'r')
		return ('\r');
	else if (c == 'v')
		return ('\v');
	else if (c == 'b')
		return ('\b');
	else if (c == 'f')
		return ('\f');
	else if (c == 'a')
		return ('\a');
	else if (c == '\\')
		return ('\\');
	else
		return (c);
}

void	handle_escape_sequence(const char *input, size_t *i,
				char *output, size_t *j)
{
	output[(*j)++] = get_escape_char(input[*i + 1]);
	*i += 2;
}

void	remove_redir_quotes(char **q, char **eq)
{
	if (**q == '"' && *(*eq - 1) == '"')
	{
		(*q)++;
		(*eq)--;
	}
}

struct s_cmd	*apply_input_redir(struct s_cmd *cmd, char *file)
{
	return (redircmd(cmd, file, NULL,
			(t_redir_params){O_RDONLY, 0}));
}

struct s_cmd	*apply_output_redir(struct s_cmd *cmd, char *file)
{
	return (redircmd(cmd, file, NULL,
			(t_redir_params){O_WRONLY | O_CREAT | O_TRUNC, 1}));
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parses_helper3.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mahajj-h <mahajj-h@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/27 00:00:00 by mahajj-h          #+#    #+#             */
/*   Updated: 2025/07/27 00:00:00 by mahajj-h         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

struct s_cmd	*apply_append_redir(struct s_cmd *cmd, char *file)
{
	return (redircmd(cmd, file, NULL,
			(t_redir_params){O_WRONLY | O_CREAT | O_APPEND, 1}));
}

struct s_cmd	*init_exec_cmd(void)
{
	struct s_cmd	*ret;

	ret = execcmd();
	return (ret);
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parses_helper4.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mahajj-h <mahajj-h@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/27 00:00:00 by mahajj-h          #+#    #+#             */
/*   Updated: 2025/07/27 00:00:00 by mahajj-h         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

struct s_cmd	*process_arguments_and_redirs(struct s_cmd *ret,
		t_process_args_params params, char **env_copy)
{
	char				*q;
	char				*eq;
	int					tok;
	t_token_type_params	token_params;

	while (! peek(params.input_ptr, params.input_end, "|)&;"))
	{
		tok = gettoken(params.input_ptr, params.input_end, &q, &eq);
		if (tok == 0)
			break ;
		token_params.ret = &ret;
		token_params.params = params;
		token_params.env_copy = env_copy;
		token_params.tok = tok;
		token_params.q = &q;
		token_params.eq = &eq;
		if (handle_token_type(token_params))
			return (NULL);
	}
	return (ret);
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parses_helper4_helper.c                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mahajj-h <mahajj-h@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/27 00:00:00 by mahajj-h          #+#    #+#             */
/*   Updated: 2025/07/27 00:00:00 by mahajj-h         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

static int	process_single_argument(t_arg_process_params arg_params)
{
	char	*processed;
	int		quote_type;

	quote_type = remove_exec_quotes(arg_params.q, arg_params.eq);
	processed = process_argument_with_expansion(*arg_params.q,
			*arg_params.eq, arg_params.env_copy, quote_type);
	if (! processed)
	{
		free_cmd(*arg_params.ret);
		return (1);
	}
	add_argument(arg_params.params.cmd, processed, arg_params.params.argc);
	return (0);
}

static int	handle_argument_token(t_arg_process_params arg_params)
{
	int							consecutive_quotes;
	t_consecutive_quotes_params	quote_params;

	consecutive_quotes = count_consecutive_quotes(arg_params.q, arg_params.eq);
	if (consecutive_quotes > 1)
	{
		quote_params.ret = arg_params.ret;
		quote_params.params = arg_params.params;
		quote_params.env_copy = arg_params.env_copy;
		quote_params.q = arg_params.q;
		quote_params.eq = arg_params.eq;
		return (process_consecutive_quotes(quote_params));
	}
	else
		return (process_single_argument(arg_params));
}

static int	handle_redirection_token_type(t_token_type_params token_params)
{
	t_redir_token_params	redir_params;

	redir_params.ret = token_params.ret;
	redir_params.params = token_params.params;
	redir_params.env_copy = token_params.env_copy;
	redir_params.tok = token_params.tok;
	redir_params.q = token_params.q;
	redir_params.eq = token_params.eq;
	return (handle_redirection_token(redir_params));
}

static int	handle_argument_token_type(t_token_type_params token_params)
{
	t_arg_process_params	arg_params;

	arg_params.ret = token_params.ret;
	arg_params.params = token_params.params;
	arg_params.env_copy = token_params.env_copy;
	arg_params.q = token_params.q;
	arg_params.eq = token_params.eq;
	return (handle_argument_token(arg_params));
}

int	handle_token_type(t_token_type_params token_params)
{
	if (token_params.tok == '"' || token_params.tok == '\'')
	{
		free_cmd(*token_params.ret);
		return (1);
	}
	if (token_params.tok == '<' || token_params.tok == '>'
		|| token_params.tok == '+' || token_params.tok == 'H')
		return (handle_redirection_token_type(token_params));
	else if (token_params.tok == 'a')
		return (handle_argument_token_type(token_params));
	else
		return (1);
	return (0);
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parses_helper5.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mahajj-h <mahajj-h@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/27 00:00:00 by mahajj-h          #+#    #+#             */
/*   Updated: 2025/07/27 00:00:00 by mahajj-h         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

void	add_argument(struct s_execcmd *cmd, char *processed, int *argc)
{
	if (*argc >= MAXARGS)
	{
		print_too_many_args();
		free(processed);
		return ;
	}
	cmd->av[*argc] = processed;
	cmd->eav[*argc] = cmd->av[*argc] + ft_strlen(processed);
	(*argc)++;
}

void	finalize_exec_cmd(struct s_execcmd *cmd, int argc)
{
	cmd->av[argc] = 0;
	cmd->eav[argc] = 0;
}

char	*allocate_and_copy_result(char *result, char *temp)
{
	size_t	total_len;
	char	*new_result;

	total_len = ft_strlen(result) + ft_strlen(temp);
	new_result = malloc(total_len + 1);
	if (! new_result)
	{
		free(result);
		free(temp);
		return (NULL);
	}
	ft_strcpy(new_result, result);
	ft_strlcat(new_result, temp, total_len + 1);
	free(result);
	free(temp);
	return (new_result);
}

char	*process_quoted_segment(char *current_pos, char *input_end,
		char **env_copy, char *result)
{
	char	*q;
	char	*eq;
	char	*temp;
	int		quote_type;

	quote_type = *current_pos;
	q = current_pos + 1;
	eq = q;
	while (eq < input_end && *eq != quote_type)
		eq++;
	if (eq >= input_end)
	{
		free(result);
		return (NULL);
	}
	temp = process_argument_with_expansion(q, eq, env_copy, quote_type);
	if (! temp)
	{
		free(result);
		return (NULL);
	}
	return (allocate_and_copy_result(result, temp));
}

char	*skip_whitespace_chars(char *current_pos, char *input_end)
{
	while (current_pos < input_end
		&& (*current_pos == ' ' || *current_pos == '\t'))
		current_pos++;
	return (current_pos);
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parses_helper6.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mahajj-h <mahajj-h@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/27 00:00:00 by mahajj-h          #+#    #+#             */
/*   Updated: 2025/07/27 00:00:00 by mahajj-h         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

int	get_exec_token(char **input_ptr, char *input_end, char **q, char **eq)
{
	int	tok;

	tok = gettoken(input_ptr, input_end, q, eq);
	if (tok == 0)
		return (0);
	if (tok != 'a')
	{
		print_missing_file_name();
		return (0);
	}
	return (tok);
}

int	remove_exec_quotes(char **q, char **eq)
{
	int	quote_type;

	quote_type = 0;
	if (**q == '"' && *(*eq - 1) == '"')
	{
		(*q)++;
		(*eq)--;
		quote_type = '"';
	}
	else if (**q == '\'' && *(*eq - 1) == '\'')
	{
		(*q)++;
		(*eq)--;
		quote_type = '\'';
	}
	return (quote_type);
}

char	*process_argument(char *q, char *eq)
{
	size_t	len;
	char	*processed;

	len = eq - q;
	processed = process_escaped(q, len);
	if (! processed)
	{
		print_malloc_failed();
		return (NULL);
	}
	return (processed);
}

char	*process_argument_with_expansion(char *q, char *eq, char **env_copy,
		int quote_type)
{
	size_t	len;
	char	*processed;
	char	*expanded;

	len = eq - q;
	processed = process_escaped(q, len);
	if (! processed)
	{
		print_malloc_failed();
		return (NULL);
	}
	if (quote_type != '\'')
	{
		expanded = expand_variables(processed, ft_strlen(processed), env_copy);
		free(processed);
		if (! expanded)
		{
			print_malloc_failed();
			return (NULL);
		}
		return (expanded);
	}
	return (processed);
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parses_helper7.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mahajj-h <mahajj-h@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/27 00:00:00 by mahajj-h          #+#    #+#             */
/*   Updated: 2025/07/27 00:00:00 by mahajj-h         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

char	*handle_quoted_string(char **current_pos, char *input_end,
		char **env_copy, char *result)
{
	result = process_quoted_segment(*current_pos, input_end, env_copy, result);
	if (! result)
		return (NULL);
	*current_pos = *current_pos + 1;
	while (*current_pos < input_end && **current_pos != '"'
		&& **current_pos != '\'')
		(*current_pos)++;
	if (*current_pos < input_end)
		(*current_pos)++;
	return (result);
}

char	*initialize_concatenation(char **input_ptr)
{
	char	*result;

	(void)input_ptr;
	result = ft_strdup("");
	if (! result)
		return (NULL);
	return (result);
}

char	*process_concatenation_loop(char *result, char *current_pos,
		char *input_end, char **env_copy)
{
	while (current_pos < input_end)
	{
		current_pos = skip_whitespace_chars(current_pos, input_end);
		if (current_pos >= input_end)
			break ;
		if (*current_pos == '"' || *current_pos == '\'')
		{
			result = handle_quoted_string(&current_pos, input_end, env_copy,
					result);
			if (! result)
				return (NULL);
		}
		else
		{
			break ;
		}
	}
	return (result);
}

char	*concatenate_quoted_strings(char **input_ptr, char *input_end,
		char **env_copy)
{
	char	*result;
	char	*current_pos;

	result = initialize_concatenation(input_ptr);
	if (! result)
		return (NULL);
	current_pos = *input_ptr;
	result = process_concatenation_loop(result, current_pos, input_end,
			env_copy);
	if (! result)
		return (NULL);
	*input_ptr = current_pos;
	return (result);
}

int	process_expanded_argument(t_expanded_arg_params params)
{
	char	*processed;
	int		quote_type;

	quote_type = remove_exec_quotes(&params.q, &params.eq);
	processed = process_argument_with_expansion(params.q,
			params.eq, params.env_copy, quote_type);
	if (! processed)
	{
		free_cmd(params.ret);
		return (1);
	}
	add_argument(params.params.cmd, processed, params.params.argc);
	return (0);
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parses_helper8.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mahajj-h <mahajj-h@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/27 00:00:00 by mahajj-h          #+#    #+#             */
/*   Updated: 2025/07/27 00:00:00 by mahajj-h         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

int	process_exec_token(struct s_cmd *ret, t_process_args_params params,
		char **env_copy)
{
	char					*q;
	char					*eq;
	int						tok;
	t_expanded_arg_params	expanded_params;

	tok = get_exec_token(params.input_ptr, params.input_end, &q, &eq);
	if (tok == 0)
		return (0);
	expanded_params.ret = ret;
	expanded_params.params = params;
	expanded_params.env_copy = env_copy;
	expanded_params.q = q;
	expanded_params.eq = eq;
	if (process_expanded_argument(expanded_params))
		return (1);
	return (0);
}

int	process_single_exec_argument(struct s_cmd *ret,
		t_process_args_params params, char **env_copy)
{
	char	*q;
	char	*eq;
	char	*processed;

	(void)env_copy;
	if (gettoken(params.input_ptr, params.input_end, &q, &eq) != 'a')
		return (1);
	processed = process_argument(q, eq);
	if (! processed)
	{
		free_cmd(ret);
		return (1);
	}
	add_argument(params.cmd, processed, params.argc);
	return (0);
}

struct s_cmd	*process_arguments(struct s_cmd *ret,
		t_process_args_params params, char **env_copy)
{
	while (peek(params.input_ptr, params.input_end, " \t\n\r"))
	{
		gettoken(params.input_ptr, params.input_end, 0, 0);
	}
	if (process_single_exec_argument(ret, params, env_copy))
		return (NULL);
	while (peek(params.input_ptr, params.input_end, " \t\n\r"))
	{
		gettoken(params.input_ptr, params.input_end, 0, 0);
	}
	return (ret);
}

struct s_cmd	*handle_heredoc_token(struct s_cmd *cmd, char *delimiter,
		char **env_copy, int is_quoted)
{
	char	*content;

	content = read_heredoc_content(delimiter, env_copy, is_quoted);
	if (! content)
		return (NULL);
	return (heredoccmd(cmd, delimiter, content));
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parses_helper9.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mahajj-h <mahajj-h@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/27 00:00:00 by mahajj-h          #+#    #+#             */
/*   Updated: 2025/07/27 00:00:00 by mahajj-h         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

int	validate_filename_token(int filename_tok, struct s_cmd **ret,
		t_process_args_params params)
{
	(void)params;
	if (filename_tok != 'a')
	{
		print_missing_file_name();
		free_cmd(*ret);
		return (1);
	}
	return (0);
}

int	check_quoted_status(char **q, char **eq)
{
	int	was_quoted;

	if (**q == '"' && *(*eq - 1) == '"')
	{
		(*q)++;
		(*eq)--;
		was_quoted = 1;
		return (was_quoted);
	}
	else if (**q == '\'' && *(*eq - 1) == '\'')
	{
		(*q)++;
		(*eq)--;
		was_quoted = 1;
		return (was_quoted);
	}
	return (0);
}

int	create_redirection_cmd(t_redir_cmd_params params)
{
	if (params.tok == '<')
		*params.ret = apply_input_redir(*params.ret, params.file_or_delimiter);
	else if (params.tok == '>')
		*params.ret = apply_output_redir(*params.ret, params.file_or_delimiter);
	else if (params.tok == '+')
		*params.ret = apply_append_redir(*params.ret, params.file_or_delimiter);
	else if (params.tok == 'h')
		*params.ret = handle_heredoc_token(*params.ret,
				params.file_or_delimiter, params.env_copy, params.was_quoted);
	return (0);
}

int	process_redirection_file(t_redir_file_params params)
{
	char				*file_or_delimiter;
	int					was_quoted;
	t_redir_cmd_params	cmd_params;

	was_quoted = check_quoted_status(params.q, params.eq);
	file_or_delimiter = process_filename(*params.q, *params.eq,
			params.env_copy);
	if (!file_or_delimiter)
	{
		free_cmd(*params.ret);
		return (1);
	}
	cmd_params.ret = params.ret;
	cmd_params.file_or_delimiter = file_or_delimiter;
	cmd_params.env_copy = params.env_copy;
	cmd_params.tok = params.tok;
	cmd_params.was_quoted = was_quoted;
	create_redirection_cmd(cmd_params);
	return (0);
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   runner.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mahajj-h <mahajj-h@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/27 00:00:00 by mahajj-h          #+#    #+#             */
/*   Updated: 2025/07/27 00:00:00 by mahajj-h         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

char	*find_command(const char *cmd, char **env_copy)
{
	char	*path;
	char	*result;

	path = get_env_value("PATH", 4, env_copy);
	if (! path || ft_strlen(path) == 0)
		return (NULL);
	result = check_absolute_path(cmd);
	if (result != (char *)1)
	{
		free(path);
		return (result);
	}
	result = search_in_paths(path, cmd);
	free(path);
	return (result);
}

void	run_exec_cmd(struct s_cmd *cmd, char **env_copy)
{
	struct s_execcmd	*ex;

	ex = (struct s_execcmd *)cmd;
	if (ex->av[0] == 0)
		clean_exit(0);
	if (is_builtin(ex->av[0]))
	{
		handle_exec_builtin(ex, cmd, &env_copy);
		return ;
	}
	execute_external_cmd(ex, env_copy);
}

void	run_redir_cmd(struct s_cmd *cmd, char **env_copy)
{
	struct s_redircmd	*rdir;
	int					saved_stdin;
	int					saved_stdout;

	rdir = (struct s_redircmd *)cmd;
	setup_redirection(rdir, &saved_stdin, &saved_stdout);
	if (open_redirection_file(rdir, saved_stdin, saved_stdout) != 0)
		return ;
	runcmd(rdir->cmd, env_copy);
	restore_redirection(rdir, saved_stdin, saved_stdout);
}

void	run_list_cmd(struct s_cmd *cmd)
{
	(void)cmd;
}

void	runcmd(struct s_cmd *cmd, char **env_copy)
{
	if (cmd == 0)
		clean_exit(0);
	if (cmd->type == EXEC)
		run_exec_cmd(cmd, env_copy);
	else if (cmd->type == REDIR)
		run_redir_cmd(cmd, env_copy);
	else if (cmd->type == HEREDOC)
		run_heredoc_cmd(cmd, env_copy);
	else if (cmd->type == PIPE)
		run_pipe_cmd(cmd, env_copy);
	else if (cmd->type == BACK)
		run_back_cmd(cmd, env_copy);
	else
	{
		ft_fprintf_stderr("unknown command type: %d\n", cmd->type);
		clean_exit(1);
	}
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   runner_helper10.c                                 :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mahajj-h <mahajj-h@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/27 00:00:00 by mahajj-h          #+#    #+#             */
/*   Updated: 2025/07/27 00:00:00 by mahajj-h         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

void	restore_stdin(int saved_stdin)
{
	dup2(saved_stdin, STDIN_FILENO);
	close(saved_stdin);
}

void	restore_stdout(int saved_stdout)
{
	dup2(saved_stdout, STDOUT_FILENO);
	close(saved_stdout);
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   runner_helper11.c                                 :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mahajj-h <mahajj-h@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/27 00:00:00 by mahajj-h          #+#    #+#             */
/*   Updated: 2025/07/27 00:00:00 by mahajj-h         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

void	wait_for_children(pid_t pid1, pid_t pid2,
	int *status1, int *status2)
{
	waitpid(pid1, status1, 0);
	waitpid(pid2, status2, 0);
}

void	handle_pipe_status(int status2)
{
	if (WIFEXITED(status2))
		set_exit_status(WEXITSTATUS(status2));
	else if (WIFSIGNALED(status2))
	{
		if (WTERMSIG(status2) == SIGINT)
			set_exit_status(130);
		else if (WTERMSIG(status2) == SIGQUIT)
			set_exit_status(131);
		else
			set_exit_status(128 + WTERMSIG(status2));
	}
	else
		set_exit_status(1);
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   runner_helper1.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mahajj-h <mahajj-h@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/27 00:00:00 by mahajj-h          #+#    #+#             */
/*   Updated: 2025/07/27 00:00:00 by mahajj-h         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

char	*check_absolute_path(const char *cmd)
{
	if (cmd[0] == '/' || cmd[0] == '.')
	{
		if (access(cmd, X_OK) == 0)
			return (ft_strdup(cmd));
		return (NULL);
	}
	return ((char *)1);
}

char	*search_in_paths(char *path, const char *cmd)
{
	char	*curr;
	char	*next;
	char	full_path[1024];
	size_t	len;

	curr = path;
	while (curr && *curr)
	{
		len = get_path_segment_len(curr, &next);
		if (build_full_path(full_path, curr, len, cmd))
			return (NULL);
		if (access(full_path, X_OK) == 0)
			return (ft_strdup(full_path));
		if (!next)
			break ;
		curr = next + 1;
	}
	return (NULL);
}

void	expand_exec_args(struct s_execcmd *ex, char **env_copy)
{
	int		i;
	char	*original;

	i = 0;
	while (ex->av[i])
	{
		original = ex->av[i];
		ex->av[i] = expand_variables(original, ft_strlen(original), env_copy);
		free(original);
		i++;
	}
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   runner_helper2.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mahajj-h <mahajj-h@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/27 00:00:00 by mahajj-h          #+#    #+#             */
/*   Updated: 2025/07/27 00:00:00 by mahajj-h         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

size_t	get_path_segment_len(char *curr, char **next)
{
	size_t	len;

	*next = ft_strchr(curr, ':');
	if (*next)
		len = (size_t)(*next - curr);
	else
		len = ft_strlen(curr);
	return (len);
}

int	build_full_path(char *full_path, char *curr,
		size_t len, const char *cmd)
{
	if (len + ft_strlen(cmd) + 2 > 1024)
	{
		print_path_too_long(curr, cmd);
		return (1);
	}
	ft_strncpy(full_path, curr, len);
	full_path[len] = '/';
	ft_strcpy(full_path + len + 1, cmd);
	return (0);
}

void	reset_signals(void)
{
	struct sigaction	sa;

	sa.sa_handler = SIG_DFL;
	sigemptyset(&sa.sa_mask);
	sa.sa_flags = SA_RESTART;
	sigaction(SIGINT, &sa, NULL);
	sigaction(SIGQUIT, &sa, NULL);
}

void	handle_exec_builtin(struct s_execcmd *ex, struct s_cmd *cmd,
		char ***env_copy)
{
	int	status;

	(void)cmd;
	status = handle_builtin(ex->av, env_copy);
	set_exit_status(status);
}

int	open_redir_file_create(struct s_redircmd *rdir)
{
	int	fd;
	int	save_errno;

	fd = open(rdir->file, rdir->mode, 0644);
	if (fd < 0)
	{
		save_errno = errno;
		print_open_failed(rdir->file, strerror(save_errno));
		return (1);
	}
	if (fd != rdir->fd)
	{
		if (dup2(fd, rdir->fd) < 0)
		{
			save_errno = errno;
			print_dup2_failed(strerror(save_errno));
			close(fd);
			return (1);
		}
		close(fd);
	}
	return (0);
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   runner_helper3.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mahajj-h <mahajj-h@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/27 00:00:00 by mahajj-h          #+#    #+#             */
/*   Updated: 2025/07/27 00:00:00 by mahajj-h         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

int	open_redir_file_regular(struct s_redircmd *rdir)
{
	int	fd;
	int	save_errno;

	fd = open(rdir->file, rdir->mode);
	if (fd < 0)
	{
		save_errno = errno;
		print_open_failed(rdir->file, strerror(save_errno));
		return (1);
	}
	if (fd != rdir->fd)
	{
		if (dup2(fd, rdir->fd) < 0)
		{
			save_errno = errno;
			print_dup2_failed(strerror(save_errno));
			close(fd);
			return (1);
		}
		close(fd);
	}
	return (0);
}

/* List command functions removed - semicolon not supported in this minishell */
void	handle_list_builtin(struct s_execcmd *ex)
{
	(void)ex;
}

void	handle_list_external(struct s_cmd *cmd)
{
	(void)cmd;
}

void	process_list_left(struct s_listcmd *list)
{
	(void)list;
}

void	process_list_right(struct s_listcmd *list)
{
	(void)list;
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   runner_helper4.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mahajj-h <mahajj-h@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/27 00:00:00 by mahajj-h          #+#    #+#             */
/*   Updated: 2025/07/27 00:00:00 by mahajj-h         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

void	setup_pipe_left(int *p, struct s_pipecmd *pipecmd, char **env_copy)
{
	(void)p;
	(void)pipecmd;
	(void)env_copy;
}

void	setup_pipe_right(int *p, struct s_pipecmd *pipecmd, char **env_copy)
{
	(void)p;
	(void)pipecmd;
	(void)env_copy;
}

void	run_heredoc_cmd(struct s_cmd *cmd, char **env_copy)
{
	struct s_heredoccmd	*hcmd;
	int					pipe_fd[2];
	pid_t				pid;
	int					saved_stdin;

	hcmd = (struct s_heredoccmd *)cmd;
	if (setup_heredoc_pipe(pipe_fd, &saved_stdin))
		return ;
	pid = create_heredoc_child(pipe_fd, hcmd);
	if (pid < 0)
	{
		close(saved_stdin);
		return ;
	}
	if (check_heredoc_child_status(pid, pipe_fd, saved_stdin))
		return ;
	if (setup_stdin_redirection(pipe_fd, saved_stdin))
		return ;
	runcmd(hcmd->cmd, env_copy);
	dup2(saved_stdin, STDIN_FILENO);
	close(saved_stdin);
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   runner_helper5.c                                  :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mahajj-h <mahajj-h@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/27 00:00:00 by mahajj-h          #+#    #+#             */
/*   Updated: 2025/07/27 00:00:00 by mahajj-h         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

void	handle_redir_error(struct s_redircmd *rdir, int saved_stdin,
		int saved_stdout)
{
	set_exit_status(1);
	if (rdir->fd == STDIN_FILENO)
		restore_stdin(saved_stdin);
	else if (rdir->fd == STDOUT_FILENO)
		restore_stdout(saved_stdout);
}

int	setup_redirection(struct s_redircmd *rdir, int *saved_stdin,
		int *saved_stdout)
{
	if (rdir->fd == STDIN_FILENO)
		*saved_stdin = dup(STDIN_FILENO);
	else if (rdir->fd == STDOUT_FILENO)
		*saved_stdout = dup(STDOUT_FILENO);
	close(rdir->fd);
	return (0);
}

int	open_redirection_file(struct s_redircmd *rdir, int saved_stdin,
		int saved_stdout)
{
	if ((rdir->mode & O_CREAT) && (rdir->mode & (O_WRONLY | O_RDWR)))
	{
		if (open_redir_file_create(rdir) != 0)
		{
			handle_redir_error(rdir, saved_stdin, saved_stdout);
			return (-1);
		}
	}
	else
	{
		if (open_redir_file_regular(rdir) != 0)
		{
			handle_redir_error(rdir, saved_stdin, saved_stdout);
			return (-1);
		}
	}
	return (0);
}

void	restore_redirection(struct s_redircmd *rdir, int saved_stdin,
		int saved_stdout)
{
	if (rdir->fd == STDIN_FILENO)
		restore_stdin(saved_stdin);
	else if (rdir->fd == STDOUT_FILENO)
		restore_stdout(saved_stdout);
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   runner_helper6.c                                  :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mahajj-h <mahajj-h@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/27 00:00:00 by mahajj-h          #+#    #+#             */
/*   Updated: 2025/07/27 00:00:00 by mahajj-h         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

void	handle_child_process(char *cmd_path, char **av, char **env_copy)
{
	reset_signals();
	execve(cmd_path, av, env_copy);
	perror("execve failed");
	free(cmd_path);
	clean_exit(1);
}

void	handle_parent_process(pid_t pid, char *cmd_path, int *status)
{
	free(cmd_path);
	waitpid(pid, status, 0);
}

void	handle_exit_status(int status)
{
	if (WIFEXITED(status))
		set_exit_status(WEXITSTATUS(status));
	else if (WIFSIGNALED(status))
	{
		if (WTERMSIG(status) == SIGINT)
			set_exit_status(130);
		else if (WTERMSIG(status) == SIGQUIT)
			set_exit_status(131);
		else
			set_exit_status(128 + WTERMSIG(status));
	}
	else
		set_exit_status(1);
}

void	execute_external_cmd(struct s_execcmd *ex, char **env_copy)
{
	char	*cmd_path;
	pid_t	pid;
	int		status;

	cmd_path = find_command(ex->av[0], env_copy);
	if (! cmd_path)
	{
		print_command_not_found(ex->av[0]);
		set_exit_status(127);
		return ;
	}
	pid = fork();
	if (pid < 0)
	{
		perror("fork failed");
		free(cmd_path);
		set_exit_status(1);
		return ;
	}
	if (pid == 0)
		handle_child_process(cmd_path, ex->av, env_copy);
	else
		handle_parent_process(pid, cmd_path, &status);
	handle_exit_status(status);
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   runner_helper7.c                                  :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mahajj-h <mahajj-h@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/27 00:00:00 by mahajj-h          #+#    #+#             */
/*   Updated: 2025/07/27 00:00:00 by mahajj-h         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

int	setup_pipe(int *p)
{
	if (pipe(p) < 0)
	{
		perror("pipe failed");
		set_exit_status(1);
		return (0);
	}
	return (1);
}

int	create_first_child(int *p, struct s_pipecmd *pipecmd,
	char **env_copy)
{
	pid_t	pid1;

	pid1 = fork();
	if (pid1 < 0)
	{
		perror("fork failed");
		close(p[0]);
		close(p[1]);
		set_exit_status(1);
		return (-1);
	}
	if (pid1 == 0)
	{
		close(p[0]);
		dup2(p[1], STDOUT_FILENO);
		close(p[1]);
		runcmd(pipecmd->left, env_copy);
		exit(get_exit_status());
	}
	return (pid1);
}

int	create_second_child(int *p, struct s_pipecmd *pipecmd,
	char **env_copy,
		pid_t pid1)
{
	pid_t	pid2;

	pid2 = fork();
	if (pid2 < 0)
	{
		perror("fork failed");
		close(p[0]);
		close(p[1]);
		kill(pid1, SIGTERM);
		waitpid(pid1, NULL, 0);
		set_exit_status(1);
		return (-1);
	}
	if (pid2 == 0)
	{
		close(p[1]);
		dup2(p[0], STDIN_FILENO);
		close(p[0]);
		runcmd(pipecmd->right, env_copy);
		exit(get_exit_status());
	}
	return (pid2);
}

void	run_pipe_cmd(struct s_cmd *cmd, char **env_copy)
{
	t_pipe_cmd_params	params;

	params.pipecmd = (struct s_pipecmd *)cmd;
	if (! setup_pipe(params.p))
		return ;
	params.pid1 = create_first_child(params.p, params.pipecmd, env_copy);
	if (params.pid1 == -1)
		return ;
	params.pid2 = create_second_child(params.p,
			params.pipecmd, env_copy, params.pid1);
	if (params.pid2 == -1)
		return ;
	close(params.p[0]);
	close(params.p[1]);
	wait_for_children(params.pid1, params.pid2,
		&params.status1, &params.status2);
	handle_pipe_status(params.status2);
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   runner_helper8.c                                  :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mahajj-h <mahajj-h@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/27 00:00:00 by mahajj-h          #+#    #+#             */
/*   Updated: 2025/07/27 00:00:00 by mahajj-h         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

void	handle_background_child(struct s_backcmd *backcmd, char **env_copy)
{
	runcmd(backcmd->cmd, env_copy);
	exit(get_exit_status());
}

void	handle_background_status(int status)
{
	if (WIFEXITED(status))
		set_exit_status(WEXITSTATUS(status));
	else if (WIFSIGNALED(status))
	{
		if (WTERMSIG(status) == SIGINT)
			set_exit_status(130);
		else if (WTERMSIG(status) == SIGQUIT)
			set_exit_status(131);
		else
			set_exit_status(128 + WTERMSIG(status));
	}
	else
		set_exit_status(1);
}

void	run_back_cmd(struct s_cmd *cmd, char **env_copy)
{
	struct s_backcmd	*backcmd;
	pid_t				pid;
	int					status;

	backcmd = (struct s_backcmd *)cmd;
	pid = fork();
	if (pid < 0)
	{
		perror("fork failed");
		set_exit_status(1);
		return ;
	}
	if (pid == 0)
		handle_background_child(backcmd, env_copy);
	waitpid(pid, &status, 0);
	handle_background_status(status);
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   runner_helper9.c                                  :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mahajj-h <mahajj-h@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/27 00:00:00 by mahajj-h          #+#    #+#             */
/*   Updated: 2025/07/27 00:00:00 by mahajj-h         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

int	setup_heredoc_pipe(int *pipe_fd, int *saved_stdin)
{
	*saved_stdin = dup(STDIN_FILENO);
	if (*saved_stdin < 0)
	{
		perror("dup failed");
		set_exit_status(1);
		return (1);
	}
	if (pipe(pipe_fd) < 0)
	{
		perror("pipe failed");
		close(*saved_stdin);
		set_exit_status(1);
		return (1);
	}
	return (0);
}

int	create_heredoc_child(int *pipe_fd, struct s_heredoccmd *hcmd)
{
	pid_t	pid;

	pid = fork();
	if (pid < 0)
	{
		perror("fork failed");
		close(pipe_fd[0]);
		close(pipe_fd[1]);
		set_exit_status(1);
		return (-1);
	}
	if (pid == 0)
	{
		close(pipe_fd[0]);
		if (hcmd->content && ft_strlen(hcmd->content) > 0)
		{
			write(pipe_fd[1], hcmd->content, ft_strlen(hcmd->content));
		}
		close(pipe_fd[1]);
		clean_exit(0);
	}
	return (pid);
}

int	check_heredoc_child_status(int pid, int *pipe_fd, int saved_stdin)
{
	int	status;

	close(pipe_fd[1]);
	waitpid(pid, &status, 0);
	if (WIFEXITED(status) && WEXITSTATUS(status) != 0)
	{
		close(pipe_fd[0]);
		close(saved_stdin);
		set_exit_status(WEXITSTATUS(status));
		return (1);
	}
	return (0);
}

int	setup_stdin_redirection(int *pipe_fd, int saved_stdin)
{
	if (dup2(pipe_fd[0], STDIN_FILENO) < 0)
	{
		perror("dup2 failed");
		close(pipe_fd[0]);
		close(saved_stdin);
		set_exit_status(1);
		return (1);
	}
	close(pipe_fd[0]);
	return (0);
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   tokenize.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mahajj-h <mahajj-h@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/27 00:00:00 by mahajj-h          #+#    #+#             */
/*   Updated: 2025/07/27 00:00:00 by mahajj-h         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

int	gettoken(char **input_ptr, char *input_end,
		char **token_start, char **token_end)
{
	char	*s;
	int		ret;
	char	space[6];
	char	symbols[8];

	init_token_arrays(space, symbols);
	setup_token_processing(input_ptr, input_end, token_start, &s);
	ret = *s;
	if (*s == 0)
		;
	else
		ret = handle_token_cases(&s, *input_ptr, input_end);
	if (ret == 0)
		return (0);
	if (token_end)
		*token_end = s;
	s = skip_whitespace(s, input_end, space);
	*input_ptr = s;
	return (ret);
}

int	peek(char **input_ptr, char *input_end, char *toks)
{
	char	*s;
	char	space[6];

	init_space_array(space);
	s = *input_ptr;
	while (s < input_end && ft_strchr(space, *s))
		s++;
	return (*s && ft_strchr(toks, *s));
}

struct s_cmd	*tokenize(const char *line, char **env_copy)
{
	char			*input;
	char			*input_ptr;
	char			*input_end;
	struct s_cmd	*cmd;

	input = ft_strdup(line);
	if (! input)
		return (NULL);
	input_ptr = input;
	input_end = input + ft_strlen(input);
	cmd = parse_line(&input_ptr, input_end, env_copy);
	peek(&input_ptr, input_end, "\0");
	if (input_ptr != input_end)
	{
		print_syntax_error();
		free_cmd(cmd);
		free(input);
		return (NULL);
	}
	free(input);
	return (cmd);
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   tokenize_helper1.c                                :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mahajj-h <mahajj-h@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/27 00:00:00 by mahajj-h          #+#    #+#             */
/*   Updated: 2025/07/27 00:00:00 by mahajj-h         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

int	is_escaped(const char *s, const char *start)
{
	(void)s;
	(void)start;
	return (0);
}

char	*skip_whitespace(char *s, char *input_end, char *space)
{
	while (s < input_end && ft_strchr(space, *s))
		s++;
	return (s);
}

int	handle_special_chars(char **s_ptr, char *input_ptr)
{
	int	ret;

	ret = handle_basic_symbols(s_ptr, input_ptr);
	if (ret != -1)
		return (ret);
	ret = handle_greater_than(s_ptr, input_ptr);
	if (ret != -1)
		return (ret);
	ret = handle_less_than(s_ptr, input_ptr);
	if (ret != -1)
		return (ret);
	return ('a');
}

char	*handle_default_token(char *s, char *input_end, char *input_ptr,
		t_token_params params)
{
	char	quote;

	(void)input_ptr;
	quote = 0;
	while (s < input_end)
	{
		if (! quote)
		{
			if (ft_strchr(params.symbols, *s) || ft_strchr(params.space, *s))
				break ;
			if (*s == '"' || *s == '\'')
				quote = *s;
		}
		else if (quote && *s == quote)
		{
			quote = 0;
		}
		s++;
	}
	if (quote)
	{
		return (NULL);
	}
	return (s);
}

int	handle_token_cases(char **s_ptr, char *input_ptr,
		char *input_end)
{
	int							ret;
	t_process_default_params	params;
	char						space[6];
	char						symbols[8];

	init_token_arrays(space, symbols);
	ret = handle_special_chars(s_ptr, input_ptr);
	if (ret == 'a')
	{
		params.s_ptr = s_ptr;
		params.input_end = input_end;
		params.input_ptr = input_ptr;
		params.symbols = symbols;
		params.space = space;
		ret = process_default_case(s_ptr, input_end, params);
	}
	return (ret);
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   tokenize_helper2.c                                :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mahajj-h <mahajj-h@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/27 00:00:00 by mahajj-h          #+#    #+#             */
/*   Updated: 2025/07/27 00:00:00 by mahajj-h         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

int	handle_basic_symbols(char **s_ptr, char *input_ptr)
{
	char	*s;
	int		ret;

	s = *s_ptr;
	ret = *s;
	if (*s == '|' || *s == '&' || *s == '('
		|| *s == ')')
	{
		if (!is_escaped(s, input_ptr))
		{
			s++;
			*s_ptr = s;
			return (ret);
		}
		*s_ptr = s;
		return ('a');
	}
	*s_ptr = s;
	return (-1);
}

int	handle_greater_than(char **s_ptr, char *input_ptr)
{
	char	*s;
	int		ret;

	s = *s_ptr;
	ret = *s;
	if (*s == '>')
	{
		if (!is_escaped(s, input_ptr))
		{
			s++;
			if (*s == '>' && !is_escaped(s, input_ptr))
			{
				ret = '+';
				s++;
			}
			*s_ptr = s;
			return (ret);
		}
		*s_ptr = s;
		return ('a');
	}
	*s_ptr = s;
	return (-1);
}

void	init_space_array(char *space)
{
	space[0] = ' ';
	space[1] = '\t';
	space[2] = '\r';
	space[3] = '\n';
	space[4] = '\v';
	space[5] = '\0';
}

void	init_symbols_array(char *symbols)
{
	symbols[0] = '<';
	symbols[1] = '>';
	symbols[2] = '|';
	symbols[3] = '&';
	symbols[4] = '(';
	symbols[5] = ')';
	symbols[6] = '\0';
}

int	handle_less_than(char **s_ptr, char *input_ptr)
{
	char	*s;
	int		ret;

	s = *s_ptr;
	ret = *s;
	if (*s == '<')
	{
		if (!is_escaped(s, input_ptr))
		{
			s++;
			if (*s == '<' && !is_escaped(s, input_ptr))
			{
				ret = 'H';
				s++;
			}
			*s_ptr = s;
			return (ret);
		}
		*s_ptr = s;
		return ('a');
	}
	*s_ptr = s;
	return (-1);
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   tokenize_helper3.c                                :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mahajj-h <mahajj-h@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/27 00:00:00 by mahajj-h          #+#    #+#             */
/*   Updated: 2025/07/27 00:00:00 by mahajj-h         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

t_token_params	setup_token_params(char *s, char *input_end,
		t_token_params params)
{
	params.s = s;
	params.input_end = input_end;
	return (params);
}

int	process_default_case(char **s_ptr, char *input_end,
		t_process_default_params params)
{
	t_token_params	token_params;
	char			*new_s_ptr;

	token_params.input_ptr = params.input_ptr;
	token_params.symbols = params.symbols;
	token_params.space = params.space;
	token_params = setup_token_params(*s_ptr, input_end, token_params);
	new_s_ptr = handle_default_token(*s_ptr, input_end, params.input_ptr,
			token_params);
	if (! new_s_ptr)
		return (0);
	*s_ptr = new_s_ptr;
	return ('a');
}

void	setup_token_processing(char **input_ptr, char *input_end,
		char **token_start, char **s_ptr)
{
	char	space[6];
	char	symbols[8];

	init_token_arrays(space, symbols);
	*s_ptr = *input_ptr;
	*s_ptr = skip_whitespace(*s_ptr, input_end, space);
	if (token_start)
		*token_start = *s_ptr;
}

void	init_token_arrays(char *space, char *symbols)
{
	init_space_array(space);
	init_symbols_array(symbols);
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   utils1.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mahajj-h <mahajj-h@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/27 00:00:00 by mahajj-h          #+#    #+#             */
/*   Updated: 2025/07/27 00:00:00 by mahajj-h         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

void	free_cmd(struct s_cmd *cmd)
{
	if (! cmd)
		return ;
	if (cmd->type == EXEC)
		free_exec_cmd((struct s_execcmd *)cmd);
	else if (cmd->type == REDIR)
		free_redir_cmd((struct s_redircmd *)cmd);
	else if (cmd->type == HEREDOC)
		free_heredoc_cmd((struct s_heredoccmd *)cmd);
	else if (cmd->type == PIPE)
		free_pipe_cmd((struct s_pipecmd *)cmd);
	else if (cmd->type == BACK)
		free_back_cmd((struct s_backcmd *)cmd);
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   utils1_helper.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mahajj-h <mahajj-h@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/27 00:00:00 by mahajj-h          #+#    #+#             */
/*   Updated: 2025/07/27 00:00:00 by mahajj-h         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

void	handle_redir_case(struct s_cmd *cmd)
{
	struct s_redircmd	*rcmd;

	if (! cmd)
		return ;
	rcmd = (struct s_redircmd *)cmd;
	if (rcmd->cmd)
		nulterm(rcmd->cmd);
	if (rcmd->efile)
		*rcmd->efile = 0;
}

void	handle_pipe_case(struct s_cmd *cmd)
{
	struct s_pipecmd	*pcmd;

	if (! cmd)
		return ;
	pcmd = (struct s_pipecmd *)cmd;
	if (pcmd->left)
		nulterm(pcmd->left);
	if (pcmd->right)
		nulterm(pcmd->right);
}

void	handle_back_case(struct s_cmd *cmd)
{
	struct s_backcmd	*bcmd;

	if (! cmd)
		return ;
	bcmd = (struct s_backcmd *)cmd;
	if (bcmd->cmd)
		nulterm(bcmd->cmd);
}

void	handle_heredoc_case(struct s_cmd *cmd)
{
	struct s_heredoccmd	*hcmd;

	if (! cmd)
		return ;
	hcmd = (struct s_heredoccmd *)cmd;
	if (hcmd->cmd)
		nulterm(hcmd->cmd);
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   utils2.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mahajj-h <mahajj-h@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/27 00:00:00 by mahajj-h          #+#    #+#             */
/*   Updated: 2025/07/27 00:00:00 by mahajj-h         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

void	free_heredoc_cmd(struct s_heredoccmd *hcmd)
{
	if (! hcmd)
		return ;
	if (hcmd->cmd)
		free_cmd(hcmd->cmd);
	if (hcmd->delimiter)
	{
		free(hcmd->delimiter);
		hcmd->delimiter = NULL;
	}
	if (hcmd->content)
	{
		free(hcmd->content);
		hcmd->content = NULL;
	}
	free(hcmd);
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   utils2_helper.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mahajj-h <mahajj-h@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/27 00:00:00 by mahajj-h          #+#    #+#             */
/*   Updated: 2025/07/27 00:00:00 by mahajj-h         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

void	free_exec_cmd(struct s_execcmd *ecmd)
{
	int	i;

	if (! ecmd)
		return ;
	i = 0;
	while (ecmd->av[i])
	{
		if (ecmd->av[i])
		{
			free(ecmd->av[i]);
			ecmd->av[i] = NULL;
		}
		i++;
	}
	free(ecmd);
}

void	free_redir_cmd(struct s_redircmd *rcmd)
{
	if (! rcmd)
		return ;
	if (rcmd->cmd)
		free_cmd(rcmd->cmd);
	if (rcmd->file)
	{
		free(rcmd->file);
		rcmd->file = NULL;
	}
	if (rcmd->efile)
	{
		free(rcmd->efile);
		rcmd->efile = NULL;
	}
	free(rcmd);
}

void	free_pipe_cmd(struct s_pipecmd *pcmd)
{
	if (! pcmd)
		return ;
	if (pcmd->left)
		free_cmd(pcmd->left);
	if (pcmd->right)
		free_cmd(pcmd->right);
	free(pcmd);
}

void	free_back_cmd(struct s_backcmd *bcmd)
{
	if (! bcmd)
		return ;
	if (bcmd->cmd)
		free_cmd(bcmd->cmd);
	free(bcmd);
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   utils3.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mahajj-h <mahajj-h@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/27 00:00:00 by mahajj-h          #+#    #+#             */
/*   Updated: 2025/07/27 00:00:00 by mahajj-h         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

int	ft_strcmp(const char *s1, const char *s2)
{
	while (*s1 && *s2 && *s1 == *s2)
	{
		s1++;
		s2++;
	}
	return ((unsigned char)*s1 - (unsigned char)*s2);
}

int	ft_snprintf(char *str, size_t size, const char *format, ...)
{
	(void)str;
	(void)size;
	(void)format;
	return (0);
}

int	ft_setenv(const char *name, const char *value, int overwrite,
		char ***env_copy)
{
	int		i;
	int		name_len;

	if (! name || ! *name || ft_strchr(name, '=') || ! env_copy || ! *env_copy)
		return (-1);
	name_len = ft_strlen(name);
	i = 0;
	while ((*env_copy)[i])
	{
		if (ft_strncmp((*env_copy)[i], name, name_len) == 0
			&& (*env_copy)[i][name_len] == '=')
		{
			if (! overwrite)
				return (0);
			return (update_existing_var(env_copy, i, name, value));
		}
		i++;
	}
	return (add_new_var(env_copy, name, value));
}

int	ft_unsetenv(const char *name, char ***env_copy)
{
	int		name_len;
	int		var_index;

	if (! name || ! *name || ft_strchr(name, '=') || ! env_copy || ! *env_copy)
		return (-1);
	name_len = ft_strlen(name);
	var_index = find_var_index(env_copy, name, name_len);
	if (var_index == -1)
		return (0);
	return (remove_var_from_env(env_copy, var_index));
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   utils3_helper1.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mahajj-h <mahajj-h@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/27 00:00:00 by mahajj-h          #+#    #+#             */
/*   Updated: 2025/07/27 00:00:00 by mahajj-h         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

void	print_too_many_args(void)
{
	ft_putstr_fd("minishell: too many arguments\n", STDERR_FILENO);
}

void	print_missing_paren(const char *paren)
{
	ft_putstr_fd("minishell: missing ", STDERR_FILENO);
	ft_putstr_fd((char *)paren, STDERR_FILENO);
	ft_putstr_fd("\n", STDERR_FILENO);
}

void	print_unknown_command_type(int type)
{
	char	*type_str;

	type_str = ft_itoa(type);
	ft_putstr_fd("unknown command type: ", STDERR_FILENO);
	if (type_str)
	{
		ft_putstr_fd(type_str, STDERR_FILENO);
		free(type_str);
	}
	ft_putstr_fd("\n", STDERR_FILENO);
}

void	print_heredoc_eof_warning(const char *delimiter)
{
	ft_putstr_fd(
		"minishell: warning: here-document delimited by end-of-file (wanted `",
		STDERR_FILENO);
	ft_putstr_fd((char *)delimiter, STDERR_FILENO);
	ft_putstr_fd("')\n", STDERR_FILENO);
}

int	ft_fprintf_stderr(const char *format, ...)
{
	if (ft_strcmp(format, "minishell: cd: HOME not set\n") == 0)
		print_cd_home_not_set();
	else if (ft_strcmp(format, "minishell: cd: getcwd failed\n") == 0)
		print_cd_getcwd_failed();
	else if (ft_strcmp(format, "minishell: cd: too many arguments\n") == 0)
		print_cd_too_many_args();
	else if (ft_strcmp(format, "minishell: syntax error\n") == 0)
		print_syntax_error();
	else if (ft_strcmp(format, "minishell: missing file name\n") == 0)
		print_missing_file_name();
	else if (ft_strcmp(format, "minishell: malloc failed\n") == 0)
		print_malloc_failed();
	else if (ft_strcmp(format, "minishell: too many arguments\n") == 0)
		print_too_many_args();
	else if (ft_strcmp(format, "minishell: missing (\n") == 0)
		print_missing_paren("(");
	else if (ft_strcmp(format, "minishell: missing )\n") == 0)
		print_missing_paren(")");
	else if (ft_strcmp(format, "minishell: exit: too many arguments\n") == 0)
		print_exit_too_many_args();
	else
		printf("%s", format);
	return (0);
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   utils3_helper2.c                                  :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mahajj-h <mahajj-h@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/27 00:00:00 by mahajj-h          #+#    #+#             */
/*   Updated: 2025/07/27 00:00:00 by mahajj-h         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

int	update_existing_var(char ***env_copy, int i, const char *name,
		const char *value)
{
	char	*new_var;

	new_var = malloc(ft_strlen(name) + ft_strlen(value) + 2);
	if (! new_var)
		return (-1);
	ft_strcpy(new_var, name);
	ft_strlcat(new_var, "=", ft_strlen(name) + 2);
	ft_strlcat(new_var, value, ft_strlen(name) + ft_strlen(value) + 2);
	free((*env_copy)[i]);
	(*env_copy)[i] = new_var;
	return (0);
}

int	count_env_vars(char ***env_copy)
{
	int	i;

	i = 0;
	while ((*env_copy)[i])
		i++;
	return (i);
}

int	allocate_new_environ(char ***env_copy, char **new_var,
		char ***new_environ)
{
	int	count;

	count = count_env_vars(env_copy);
	*new_environ = malloc((count + 2) * sizeof(char *));
	if (! *new_environ)
	{
		free(*new_var);
		return (-1);
	}
	return (count);
}

void	copy_existing_env_vars(char ***env_copy, char **new_environ,
		int count)
{
	int	i;

	i = 0;
	while (i < count)
	{
		new_environ[i] = (*env_copy)[i];
		i++;
	}
}

void	finalize_new_environ(char **new_environ, int count,
	char *new_var,
		char ***env_copy)
{
	new_environ[count] = new_var;
	new_environ[count + 1] = NULL;
	free(*env_copy);
	*env_copy = new_environ;
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   utils3_helper3.c                                  :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mahajj-h <mahajj-h@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/27 00:00:00 by mahajj-h          #+#    #+#             */
/*   Updated: 2025/07/27 00:00:00 by mahajj-h         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

int	count_total_vars(char ***env_copy)
{
	int	total_vars;

	total_vars = 0;
	while ((*env_copy)[total_vars])
		total_vars++;
	return (total_vars);
}

void	copy_vars_except_index(char ***env_copy, char **new_environ,
		int var_index)
{
	int	i;
	int	j;

	i = 0;
	j = 0;
	while ((*env_copy)[i])
	{
		if (i != var_index)
		{
			new_environ[j] = (*env_copy)[i];
			j++;
		}
		i++;
	}
	new_environ[j] = NULL;
}

int	remove_var_from_env(char ***env_copy, int var_index)
{
	char	**new_environ;
	int		total_vars;

	total_vars = count_total_vars(env_copy);
	free((*env_copy)[var_index]);
	new_environ = malloc((total_vars) * sizeof(char *));
	if (! new_environ)
		return (-1);
	copy_vars_except_index(env_copy, new_environ, var_index);
	free(*env_copy);
	*env_copy = new_environ;
	return (0);
}

int	find_var_index(char ***env_copy, const char *name, int name_len)
{
	int		i;

	i = 0;
	while ((*env_copy)[i])
	{
		if (ft_strncmp((*env_copy)[i], name, name_len) == 0
			&& (*env_copy)[i][name_len] == '=')
		{
			return (i);
		}
		i++;
	}
	return (-1);
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   utils3_helper4.c                                  :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mahajj-h <mahajj-h@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/27 00:00:00 by mahajj-h          #+#    #+#             */
/*   Updated: 2025/07/27 00:00:00 by mahajj-h         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

void	*ft_realloc(void *ptr, size_t size)
{
	void	*new_ptr;

	if (! ptr)
		return (malloc(size));
	if (size == 0)
	{
		free(ptr);
		return (NULL);
	}
	new_ptr = malloc(size);
	if (! new_ptr)
		return (NULL);
	ft_memcpy(new_ptr, ptr, size);
	free(ptr);
	return (new_ptr);
}

char	*ft_strncpy(char *dest, const char *src, size_t n)
{
	size_t	i;

	i = 0;
	while (i < n && src[i])
	{
		dest[i] = src[i];
		i++;
	}
	while (i < n)
	{
		dest[i] = '\0';
		i++;
	}
	return (dest);
}

char	*ft_strcpy(char *dest, const char *src)
{
	char	*ptr;

	ptr = dest;
	while (*src)
	{
		*ptr = *src;
		ptr++;
		src++;
	}
	*ptr = '\0';
	return (dest);
}

int	ft_fflush_stdout(void)
{
	return (write(STDOUT_FILENO, "", 0));
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   utils3_helper5.c                                  :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mahajj-h <mahajj-h@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/27 00:00:00 by mahajj-h          #+#    #+#             */
/*   Updated: 2025/07/27 00:00:00 by mahajj-h         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

int	add_new_var(char ***env_copy, const char *name,
	const char *value)
{
	char	*new_var;
	char	**new_environ;
	int		count;

	new_var = malloc(ft_strlen(name) + ft_strlen(value) + 2);
	if (! new_var)
		return (-1);
	ft_strcpy(new_var, name);
	ft_strlcat(new_var, "=", ft_strlen(name) + 2);
	ft_strlcat(new_var, value, ft_strlen(name) + ft_strlen(value) + 2);
	count = allocate_new_environ(env_copy, &new_var, &new_environ);
	if (count == -1)
		return (-1);
	copy_existing_env_vars(env_copy, new_environ, count);
	finalize_new_environ(new_environ, count, new_var, env_copy);
	return (0);
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   utils3_helper6.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mahajj-h <mahajj-h@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/27 00:00:00 by mahajj-h          #+#    #+#             */
/*   Updated: 2025/07/27 00:00:00 by mahajj-h         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

void	print_exit_too_many_args(void)
{
	ft_putstr_fd("minishell: exit: too many arguments\n", STDERR_FILENO);
}

void	print_command_not_found(const char *cmd)
{
	ft_putstr_fd("minishell: ", STDERR_FILENO);
	ft_putstr_fd((char *)cmd, STDERR_FILENO);
	ft_putstr_fd(": command not found\n", STDERR_FILENO);
}

void	print_syntax_error(void)
{
	ft_putstr_fd("minishell: syntax error\n", STDERR_FILENO);
}

void	print_missing_file_name(void)
{
	ft_putstr_fd("minishell: missing file name\n", STDERR_FILENO);
}

void	print_malloc_failed(void)
{
	ft_putstr_fd("minishell: malloc failed\n", STDERR_FILENO);
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   utils3_helper7.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mahajj-h <mahajj-h@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/27 00:00:00 by mahajj-h          #+#    #+#             */
/*   Updated: 2025/07/27 00:00:00 by mahajj-h         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

void	print_export_error(const char *error)
{
	ft_putstr_fd("minishell: export: ", STDERR_FILENO);
	ft_putstr_fd((char *)error, STDERR_FILENO);
	ft_putstr_fd("\n", STDERR_FILENO);
}

void	print_path_too_long(const char *curr, const char *cmd)
{
	ft_putstr_fd("Path too long: ", STDERR_FILENO);
	ft_putstr_fd((char *)curr, STDERR_FILENO);
	ft_putstr_fd("/", STDERR_FILENO);
	ft_putstr_fd((char *)cmd, STDERR_FILENO);
	ft_putstr_fd("\n", STDERR_FILENO);
}

void	print_open_failed(const char *file, const char *error)
{
	ft_putstr_fd("open failed: ", STDERR_FILENO);
	ft_putstr_fd((char *)file, STDERR_FILENO);
	ft_putstr_fd(": ", STDERR_FILENO);
	ft_putstr_fd((char *)error, STDERR_FILENO);
	ft_putstr_fd("\n", STDERR_FILENO);
}

void	print_dup2_failed(const char *error)
{
	ft_putstr_fd("dup2 failed: ", STDERR_FILENO);
	ft_putstr_fd((char *)error, STDERR_FILENO);
	ft_putstr_fd("\n", STDERR_FILENO);
}

void	print_exit_numeric_arg(const char *arg)
{
	ft_putstr_fd("minishell: exit: ", STDERR_FILENO);
	ft_putstr_fd((char *)arg, STDERR_FILENO);
	ft_putstr_fd(": numeric argument required\n", STDERR_FILENO);
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   utils3_helper8.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mahajj-h <mahajj-h@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/27 00:00:00 by mahajj-h          #+#    #+#             */
/*   Updated: 2025/07/27 00:00:00 by mahajj-h         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

void	print_cd_error(const char *path, const char *error)
{
	ft_putstr_fd("minishell: cd: ", STDERR_FILENO);
	ft_putstr_fd((char *)path, STDERR_FILENO);
	ft_putstr_fd(": ", STDERR_FILENO);
	ft_putstr_fd((char *)error, STDERR_FILENO);
	ft_putstr_fd("\n", STDERR_FILENO);
}

void	print_cd_home_not_set(void)
{
	ft_putstr_fd("minishell: cd: HOME not set\n", STDERR_FILENO);
}

void	print_cd_getcwd_failed(void)
{
	ft_putstr_fd("minishell: cd: getcwd failed\n", STDERR_FILENO);
}

void	print_cd_too_many_args(void)
{
	ft_putstr_fd("minishell: cd: too many arguments\n", STDERR_FILENO);
}

void	print_export_invalid_identifier(const char *arg)
{
	ft_putstr_fd("minishell: export: `", STDERR_FILENO);
	ft_putstr_fd((char *)arg, STDERR_FILENO);
	ft_putstr_fd("': not a valid identifier\n", STDERR_FILENO);
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   utils.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mahajj-h <mahajj-h@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/27 00:00:00 by mahajj-h          #+#    #+#             */
/*   Updated: 2025/07/27 00:00:00 by mahajj-h         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

int	is_only_whitespace(const char *str)
{
	int	i;

	if (! str)
		return (1);
	i = 0;
	while (str[i])
	{
		if (str[i] != ' ' && str[i] != '\t' && str[i] != '\n'
			&& str[i] != '\r' && str[i] != '\f' && str[i] != '\v')
			return (0);
		i++;
	}
	return (1);
}

struct s_cmd	*nulterm(struct s_cmd *cmd)
{
	if (cmd == 0)
		return (0);
	if (cmd->type == EXEC)
		handle_exec_case(cmd);
	else if (cmd->type == REDIR)
		handle_redir_case(cmd);
	else if (cmd->type == HEREDOC)
		handle_heredoc_case(cmd);
	else if (cmd->type == PIPE)
		handle_pipe_case(cmd);
	else if (cmd->type == BACK)
		handle_back_case(cmd);
	return (cmd);
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   utils_helper.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mahajj-h <mahajj-h@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/27 00:00:00 by mahajj-h          #+#    #+#             */
/*   Updated: 2025/07/27 00:00:00 by mahajj-h         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

void	*get_cwd(char *buf, size_t size)
{
	if (getcwd(buf, size) == NULL)
	{
		perror("getcwd is dead");
		return (NULL);
	}
	return (buf);
}

int	forkk(void)
{
	int	pid;

	pid = fork();
	if (pid == -1)
	{
		perror("fork failed");
		return (-1);
	}
	return (pid);
}

void	handle_internal_error(void)
{
	ft_putstr_fd("minishell: internal error\n", STDERR_FILENO);
	clean_exit(1);
}

void	handle_exec_case(struct s_cmd *cmd)
{
	int					i;
	struct s_execcmd	*ecmd;

	ecmd = (struct s_execcmd *)cmd;
	i = 0;
	while (ecmd->av[i])
	{
		*ecmd->eav[i] = 0;
		i++;
	}
}
