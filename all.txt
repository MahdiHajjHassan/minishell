#include "inc/minishell.h"

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   builtin.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mahajj-h <mahajj-h@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/27 00:00:00 by mahajj-h          #+#    #+#             */
/*   Updated: 2025/07/27 00:00:00 by mahajj-h         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

static int	process_export_arg(char *arg_copy, char **name, char **value, char ***env_copy)
{
	if (parse_export_arg(arg_copy, name, value))
	{
		free(arg_copy);
		return (1);
	}
	remove_quotes(value);
	if (set_environment_var(*name, *value, env_copy))
	{
		free(arg_copy);
		return (1);
	}
	free(arg_copy);
	return (0);
}

static int	builtin_export(char **argv, char ***env_copy)
{
	int			i;
	char		*name;
	char		*value;
	char		*arg_copy;
	char		*equals;

	/* If no arguments, print all environment variables in sorted order */
	if (!argv[1])
	{
		print_sorted_env_vars(*env_copy);
		return (0);
	}

	i = 1;
	while (argv[i])
	{
		arg_copy = ft_strdup(argv[i]);
		if (!arg_copy)
			return (1);
		
		equals = ft_strchr(arg_copy, '=');
		if (!equals)
		{
			/* Variable without value - just check if it exists, don't add it */
			/* This is valid behavior for export */
			free(arg_copy);
			i++;
			continue;
		}
		
		if (process_export_arg(arg_copy, &name, &value, env_copy))
			return (1);
		i++;
	}
	return (0);
}

static int	builtin_unset(char **argv, char ***env_copy)
{
	int	i;

	i = 1;
	while (argv[i])
	{
		if (ft_unsetenv(argv[i], env_copy) != 0)
		{
			perror("unset");
			return (1);
		}
		i++;
	}
	return (0);
}

static int	builtin_env(char **argv, char ***env_copy)
{
	int			i;

	(void)argv;
	i = 0;
	while ((*env_copy)[i])
	{
		ft_putstr_fd((*env_copy)[i], STDOUT_FILENO);
		ft_putstr_fd("\n", STDOUT_FILENO);
		i++;
	}
	return (0);
}

int	handle_builtin(char **argv, char ***env_copy)
{
	if (!argv[0])
		return (1);
	if (!ft_strcmp(argv[0], "echo"))
		return (builtin_echo(argv));
	if (!ft_strcmp(argv[0], "cd"))
		return (builtin_cd(argv, env_copy));
	if (!ft_strcmp(argv[0], "pwd"))
		return (builtin_pwd(argv));
	if (!ft_strcmp(argv[0], "export"))
		return (builtin_export(argv, env_copy));
	if (!ft_strcmp(argv[0], "unset"))
		return (builtin_unset(argv, env_copy));
	if (!ft_strcmp(argv[0], "env"))
		return (builtin_env(argv, env_copy));
	if (!ft_strcmp(argv[0], "exit"))
		return (builtin_exit(argv));
	return (1);
}


/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   builtin_helper.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mahajj-h <mahajj-h@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/27 00:00:00 by mahajj-h          #+#    #+#             */
/*   Updated: 2025/07/27 00:00:00 by mahajj-h         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

int	cd_to_home(char **env_copy)
{
	char	*home;
	int		i;

	/* Search for HOME in local environment copy */
	i = 0;
	while (env_copy && env_copy[i])
	{
		if (ft_strncmp(env_copy[i], "HOME=", 5) == 0)
		{
			home = env_copy[i] + 5;
			if (chdir(home) != 0)
			{
				ft_fprintf_stderr("minishell: cd: %s: %s\n", home, strerror(errno));
				return (1);
			}
			return (0);
		}
		i++;
	}
	
	ft_fprintf_stderr("minishell: cd: HOME not set\n");
	return (1);
}

int	cd_to_path(char *path)
{
	if (chdir(path) != 0)
	{
		ft_fprintf_stderr("minishell: cd: %s: %s\n",
			path, strerror(errno));
		return (1);
	}
	return (0);
}

int	parse_export_arg(char *arg, char **name, char **value)
{
	char	*equals;

	equals = ft_strchr(arg, '=');
	if (!equals)
	{
		ft_fprintf_stderr("minishell: export: `%s': not a valid identifier\n", arg);
		return (1);
	}
	*name = arg;
	*equals = '\0';
	*value = equals + 1;
	return (0);
}

void	remove_quotes(char **value)
{
	if (**value == '"' && (*value)[ft_strlen(*value) - 1] == '"')
	{
		(*value)++;
		(*value)[ft_strlen(*value) - 1] = '\0';
	}
	else if (**value == '\'' && (*value)[ft_strlen(*value) - 1] == '\'')
	{
		(*value)++;
		(*value)[ft_strlen(*value) - 1] = '\0';
	}
}

int	set_environment_var(char *name, char *value, char ***env_copy)
{
	if (ft_setenv(name, value, 1, env_copy) != 0)
	{
		ft_fprintf_stderr("minishell: export: %s\n", strerror(errno));
		return (1);
	}
	return (0);
}

void	print_sorted_env_vars(char **env_copy)
{
	int		i;
	int		j;
	char	*temp;
	int		count;

	/* Count environment variables */
	count = 0;
	while (env_copy && env_copy[count])
		count++;

	/* Create a copy for sorting */
	char **sorted_env = malloc((count + 1) * sizeof(char *));
	if (!sorted_env)
		return;

	/* Copy environment variables */
	i = 0;
	while (env_copy && env_copy[i])
	{
		sorted_env[i] = ft_strdup(env_copy[i]);
		i++;
	}
	sorted_env[i] = NULL;

	/* Sort environment variables */
	i = 0;
	while (sorted_env[i])
	{
		j = i + 1;
		while (sorted_env[j])
		{
			if (ft_strcmp(sorted_env[i], sorted_env[j]) > 0)
			{
				temp = sorted_env[i];
				sorted_env[i] = sorted_env[j];
				sorted_env[j] = temp;
			}
			j++;
		}
		i++;
	}

	/* Print sorted environment variables */
	i = 0;
	while (sorted_env[i])
	{
		ft_putstr_fd("declare -x ", STDOUT_FILENO);
		ft_putstr_fd(sorted_env[i], STDOUT_FILENO);
		ft_putstr_fd("\n", STDOUT_FILENO);
		i++;
	}

	/* Free sorted environment copy */
	i = 0;
	while (sorted_env[i])
	{
		free(sorted_env[i]);
		i++;
	}
	free(sorted_env);
}

void	update_pwd_variables(char *old_pwd, char *new_pwd, char ***env_copy)
{
	int		i;
	int		count;
	char	**new_environ;
	char	*old_pwd_var;
	char	*new_pwd_var;

	/* Create the variable strings */
	old_pwd_var = malloc(ft_strlen("OLDPWD") + ft_strlen(old_pwd) + 2);
	new_pwd_var = malloc(ft_strlen("PWD") + ft_strlen(new_pwd) + 2);
	if (!old_pwd_var || !new_pwd_var)
	{
		free(old_pwd_var);
		free(new_pwd_var);
		return;
	}

	ft_strcpy(old_pwd_var, "OLDPWD=");
	ft_strlcat(old_pwd_var, old_pwd, ft_strlen("OLDPWD") + ft_strlen(old_pwd) + 2);
	ft_strcpy(new_pwd_var, "PWD=");
	ft_strlcat(new_pwd_var, new_pwd, ft_strlen("PWD") + ft_strlen(new_pwd) + 2);

	/* Count existing variables */
	count = 0;
	while ((*env_copy)[count])
		count++;

	/* Allocate new array with space for both variables */
	new_environ = malloc((count + 3) * sizeof(char *));
	if (!new_environ)
	{
		free(old_pwd_var);
		free(new_pwd_var);
		return;
	}

	/* Copy existing variables, updating PWD and OLDPWD if they exist */
	i = 0;
	while ((*env_copy)[i])
	{
		if (ft_strncmp((*env_copy)[i], "OLDPWD=", 7) == 0)
		{
			free((*env_copy)[i]);
			new_environ[i] = old_pwd_var;
		}
		else if (ft_strncmp((*env_copy)[i], "PWD=", 4) == 0)
		{
			free((*env_copy)[i]);
			new_environ[i] = new_pwd_var;
		}
		else
		{
			new_environ[i] = (*env_copy)[i];
		}
		i++;
	}

	/* Add new variables if they didn't exist */
	if (i == count) /* No existing PWD or OLDPWD found */
	{
		new_environ[i] = old_pwd_var;
		new_environ[i + 1] = new_pwd_var;
		new_environ[i + 2] = NULL;
	}
	else
	{
		new_environ[i] = NULL;
	}

	/* Update environment pointer */
	free(*env_copy);
	*env_copy = new_environ;
}


/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   builtin_helper2.c                                  :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mahajj-h <mahajj-h@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/27 00:00:00 by mahajj-h          #+#    #+#             */
/*   Updated: 2025/07/27 00:00:00 by mahajj-h         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

int	builtin_echo(char **argv)
{
	int	i;
	int	print_newline;

	i = 1;
	print_newline = 1;
	while (argv[i] && argv[i][0] == '-' && argv[i][1] == 'n')
	{
		int	j;
		
		j = 2;
		while (argv[i][j] == 'n')
			j++;
		if (argv[i][j] == '\0')
		{
			print_newline = 0;
			i++;
		}
		else
			break;
	}
	while (argv[i])
	{
		ft_putstr_fd(argv[i], STDOUT_FILENO);
		if (argv[i + 1])
			ft_putstr_fd(" ", STDOUT_FILENO);
		i++;
	}
	if (print_newline)
		ft_putstr_fd("\n", STDOUT_FILENO);
	return (0);
}

int	builtin_cd(char **argv, char ***env_copy)
{
	char	*old_pwd;
	char	*new_pwd;
	char	cwd[1024];

	/* Get current directory before changing */
	if (!getcwd(cwd, sizeof(cwd)))
	{
		ft_fprintf_stderr("minishell: cd: getcwd failed\n");
		return (1);
	}
	old_pwd = ft_strdup(cwd);

	/* Change directory */
	if (!argv[1])
	{
		if (cd_to_home(*env_copy) != 0)
		{
			free(old_pwd);
			return (1);
		}
	}
	else if (argv[2])
	{
		ft_fprintf_stderr("minishell: cd: too many arguments\n");
		free(old_pwd);
		return (1);
	}
	else
	{
		if (cd_to_path(argv[1]) != 0)
		{
			free(old_pwd);
			return (1);
		}
	}

	/* Get new directory after changing */
	if (!getcwd(cwd, sizeof(cwd)))
	{
		ft_fprintf_stderr("minishell: cd: getcwd failed\n");
		free(old_pwd);
		return (1);
	}
	new_pwd = ft_strdup(cwd);

	/* Update PWD and OLDPWD in environment */
	update_pwd_variables(old_pwd, new_pwd, env_copy);

	free(old_pwd);
	free(new_pwd);
	return (0);
}

int	builtin_pwd(char **argv)
{
	char	cwd[1024];

	(void)argv;
	if (!getcwd(cwd, sizeof(cwd)))
	{
		perror("pwd");
		return (1);
	}
	ft_putstr_fd(cwd, STDOUT_FILENO);
	ft_putstr_fd("\n", STDOUT_FILENO);
	return (0);
}

int	builtin_exit(char **argv)
{
	int	status;
	int	i;

	status = 0;
	ft_putstr_fd("exit\n", STDOUT_FILENO);
	
	if (argv[1])
	{
		i = 0;
		if (argv[1][i] == '-' || argv[1][i] == '+')
			i++;
		while (argv[1][i])
		{
			if (!ft_isdigit(argv[1][i]))
			{
				ft_fprintf_stderr("minishell: exit: ", STDERR_FILENO);
				ft_fprintf_stderr(argv[1], STDERR_FILENO);
				ft_fprintf_stderr(": numeric argument required\n", STDERR_FILENO);
				clean_exit(255);
			}
			i++;
		}
		status = ft_atoi(argv[1]);
		
		if (argv[2])
		{
			ft_fprintf_stderr("minishell: exit: too many arguments\n", STDERR_FILENO);
			return (1);
		}
	}
	
	clean_exit(status);
	return (0);
}

int	is_builtin(char *cmd)
{
	if (!ft_strcmp(cmd, "echo"))
		return (1);
	if (!ft_strcmp(cmd, "cd"))
		return (1);
	if (!ft_strcmp(cmd, "pwd"))
		return (1);
	if (!ft_strcmp(cmd, "export"))
		return (1);
	if (!ft_strcmp(cmd, "unset"))
		return (1);
	if (!ft_strcmp(cmd, "env"))
		return (1);
	if (!ft_strcmp(cmd, "exit"))
		return (1);
	return (0);
}


/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   constructs.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mahajj-h <mahajj-h@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/27 00:00:00 by mahajj-h          #+#    #+#             */
/*   Updated: 2025/07/27 00:00:00 by mahajj-h         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

struct s_cmd	*execcmd(void)
{
	struct s_execcmd	*cmd;

	cmd = malloc(sizeof(*cmd));
	if (!cmd)
		return (NULL);
	ft_memset(cmd, 0, sizeof(*cmd));
	cmd->type = EXEC;
	return ((struct s_cmd *)cmd);
}

struct s_cmd	*redircmd(struct s_cmd *subcmd, char *file,
							char *efile, t_redir_params params)
{
	struct s_redircmd	*cmd;

	cmd = malloc(sizeof(*cmd));
	if (!cmd)
	{
		free_cmd(subcmd);
		free(file);
		free(efile);
		return (NULL);
	}
	ft_memset(cmd, 0, sizeof(*cmd));
	cmd->type = REDIR;
	cmd->cmd = subcmd;
	cmd->file = file;
	cmd->efile = efile;
	cmd->mode = params.mode;
	cmd->fd = params.fd;
	return ((struct s_cmd *)cmd);
}

struct s_cmd	*pipecmd(struct s_cmd *left, struct s_cmd *right)
{
	struct s_pipecmd	*cmd;

	cmd = malloc(sizeof(*cmd));
	if (!cmd)
	{
		free_cmd(left);
		free_cmd(right);
		return (NULL);
	}
	ft_memset(cmd, 0, sizeof(*cmd));
	cmd->type = PIPE;
	cmd->left = left;
	cmd->right = right;
	return ((struct s_cmd *)cmd);
}

/* List command constructor removed - semicolon not supported in this minishell */
struct s_cmd	*listcmd(struct s_cmd *left, struct s_cmd *right)
{
	(void)left;
	(void)right;
	return (NULL);
}

struct s_cmd	*backcmd(struct s_cmd *subcmd)
{
	struct s_backcmd	*cmd;

	cmd = malloc(sizeof(*cmd));
	if (!cmd)
	{
		free_cmd(subcmd);
		return (NULL);
	}
	ft_memset(cmd, 0, sizeof(*cmd));
	cmd->type = BACK;
	cmd->cmd = subcmd;
	return ((struct s_cmd *)cmd);
}

struct s_cmd	*heredoccmd(struct s_cmd *subcmd, char *delimiter, char *content)
{
	struct s_heredoccmd	*cmd;

	cmd = malloc(sizeof(*cmd));
	if (!cmd)
	{
		free(delimiter);
		free(content);
		return (NULL);
	}
	
	ft_memset(cmd, 0, sizeof(*cmd));
	cmd->type = HEREDOC;
	cmd->cmd = subcmd;
	cmd->delimiter = delimiter;
	cmd->content = content;
	cmd->fd = 0;
	
	return ((struct s_cmd *)cmd);
}


/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   env.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mahajj-h <mahajj-h@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/27 00:00:00 by mahajj-h          #+#    #+#             */
/*   Updated: 2025/07/27 00:00:00 by mahajj-h         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

static int	exit_status = 0;

void	set_exit_status(int status)
{
	exit_status = status;
}

int	get_exit_status(void)
{
	return (exit_status);
}

static char	*finalize_result(char *result, size_t j)
{
	char	*final;

	result[j] = '\0';
	final = ft_realloc(result, j + 1);
	if (final)
		return (final);
	else
		return (result);
}

char	*expand_variables(const char *str, size_t len, char **env_copy)
{
	char	*result;
	size_t	i;
	size_t	j;
	size_t	alloc_size;

	if (!str)
		return (ft_strdup(""));
	
	i = 0;
	j = 0;
	result = init_result_buffer(len, &alloc_size);
	if (!result)
		return (NULL);
	while (i < len)
	{
		if (process_character((t_process_char_params){str, len, &i,
				&result, &j, &alloc_size, env_copy}))
			return (NULL);
	}
	return (finalize_result(result, j));
}


/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   env_helper1.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   Created: 2025/07/27 00:00:00 by mahajj-h          #+#    #+#             */
/*   Updated: 2025/07/27 00:00:00 by mahajj-h         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

size_t	get_var_name_len(const char *str)
{
	size_t	len;

	len = 0;
	if (*str == '?')
		return (1);
	while (str[len] && (isalnum(str[len]) || str[len] == '_'))
		len++;
	return (len);
}

char	*get_env_value(const char *name, size_t name_len, char **env_copy)
{
	char	*temp;
	char	*value;
	int		i;

	if (name_len == 1 && *name == '?')
	{
		char *status_str = ft_itoa(get_exit_status());
		if (!status_str)
			return (ft_strdup("0"));
		return (status_str);
	}
	
	temp = malloc(name_len + 1);
	if (!temp)
		return (ft_strdup(""));
	
	ft_strncpy(temp, name, name_len);
	temp[name_len] = '\0';
	
	/* Search in local environment copy */
	if (!env_copy)
	{
		free(temp);
		return (ft_strdup(""));
	}
	
	i = 0;
	while (env_copy[i])
	{
		if (ft_strncmp(env_copy[i], temp, name_len) == 0 && env_copy[i][name_len] == '=')
		{
			value = ft_strdup(env_copy[i] + name_len + 1);
			free(temp);
			return (value);
		}
		i++;
	}
	
	free(temp);
	return (ft_strdup(""));
}

int	handle_env_variable(t_env_var_params params, char **env_copy)
{
	size_t	var_name_len;
	char	*env_value;
	size_t	value_len;

	(*params.i)++;
	var_name_len = get_var_name_len(params.str + *params.i);
	env_value = get_env_value(params.str + *params.i, var_name_len, env_copy);
	
	if (env_value)
	{
		value_len = ft_strlen(env_value);
		*params.result = resize_for_env_value(*params.result,
				params.alloc_size, *params.j, value_len);
		if (!*params.result)
		{
			free(env_value);
			return (1);
		}
		ft_strcpy(*params.result + *params.j, env_value);
		*params.j += value_len;
		free(env_value);
	}
	else
	{
		/* Handle case where env_value allocation failed */
		return (1);
	}
	
	*params.i += var_name_len;
	return (0);
}

int	handle_regular_char(t_regular_char_params params)
{
	*params.result = resize_for_char(*params.result,
			params.alloc_size, *params.j);
	if (!*params.result)
		return (1);
	(*params.result)[(*params.j)++] = params.str[(*params.i)++];
	return (0);
}

int	process_character(t_process_char_params params)
{
	if (is_variable_char(params.str, *params.i, params.len))
	{
		if (handle_env_variable((t_env_var_params){params.str, params.i,
				params.result, params.j, params.alloc_size, params.env_copy}, params.env_copy))
			return (1);
	}
	else
	{
		if (handle_regular_char((t_regular_char_params){params.str, params.i,
				params.result, params.j, params.alloc_size}))
			return (1);
	}
	return (0);
}


/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   env_helper1_helper.c                              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mahajj-h <mahajj-h@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/27 00:00:00 by mahajj-h          #+#    #+#             */
/*   Updated: 2025/07/27 00:00:00 by mahajj-h         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

char	*init_result_buffer(size_t len, size_t *alloc_size)
{
	char	*result;

	*alloc_size = len * 2;
	result = malloc(*alloc_size);
	if (!result)
		return (NULL);
	return (result);
}

char	*resize_for_env_value(char *result, size_t *alloc_size,
	size_t j, size_t value_len)
{
	char	*new_result;

	if (j + value_len >= *alloc_size)
	{
		*alloc_size = (j + value_len) * 2;
		new_result = ft_realloc(result, *alloc_size);
		if (!new_result)
		{
			free(result);
			return (NULL);
		}
		result = new_result;
	}
	return (result);
}

char	*resize_for_char(char *result, size_t *alloc_size, size_t j)
{
	char	*new_result;

	if (j + 1 >= *alloc_size)
	{
		*alloc_size *= 2;
		new_result = ft_realloc(result, *alloc_size);
		if (!new_result)
		{
			free(result);
			return (NULL);
		}
		result = new_result;
	}
	return (result);
}

int	is_variable_char(const char *str, size_t i, size_t len)
{
	if (str[i] == '$' && i + 1 < len
		&& (isalnum(str[i + 1]) || str[i + 1] == '_' || str[i + 1] == '?'))
		return (1);
	return (0);
}


/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   heredoc.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mahajj-h <mahajj-h@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/27 00:00:00 by mahajj-h          #+#    #+#             */
/*   Updated: 2025/07/27 00:00:00 by mahajj-h         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

void	setup_heredoc_signals(void)
{
	struct sigaction	sa_int;

	sa_int.sa_handler = heredoc_sigint_handler;
	sigemptyset(&sa_int.sa_mask);
	sa_int.sa_flags = SA_RESTART;
	sigaction(SIGINT, &sa_int, NULL);
}

void	heredoc_sigint_handler(int signo)
{
	(void)signo;
	write(STDERR_FILENO, "\n", 1);
	clean_exit(130);
}

/* Custom line reader that doesn't use readline to avoid history updates */
char	*read_line_without_history(void)
{
	char	buffer[4096];
	char	*line;
	int		i;
	int		c;

	i = 0;
	while (i < 4095)
	{
		c = getchar();
		if (c == EOF)
		{
			if (i == 0)
				return (NULL);
			break;
		}
		if (c == '\n')
			break;
		buffer[i++] = (char)c;
	}
	buffer[i] = '\0';
	
	line = ft_strdup(buffer);
	return (line);
}

char	*append_line_to_content(char *content, char *line)
{
	size_t	content_len;
	size_t	line_len;
	char	*new_content;

	content_len = ft_strlen(content);
	line_len = ft_strlen(line);
	
	new_content = malloc(content_len + line_len + 2);
	if (!new_content)
		return (NULL);
	
	ft_strcpy(new_content, content);
	ft_strcpy(new_content + content_len, line);
	new_content[content_len + line_len] = '\n';
	new_content[content_len + line_len + 1] = '\0';
	
	return (new_content);
}

char	*read_heredoc_content(char *delimiter)
{
	char	*content;
	char	*line;
	char	*new_content;
	size_t	delimiter_len;

	content = ft_strdup("");
	if (!content)
		return (NULL);
	
	delimiter_len = ft_strlen(delimiter);
	setup_heredoc_signals();
	
	while (1)
	{
		write(STDOUT_FILENO, "> ", 2);
		line = read_line_without_history();
		
		if (!line)
		{
			ft_fprintf_stderr("minishell: warning: here-document delimited by end-of-file (wanted `%s')\n", delimiter);
			break;
		}
		
		if (ft_strlen(line) == delimiter_len && ft_strncmp(line, delimiter, delimiter_len) == 0)
		{
			free(line);
			break;
		}
		
		new_content = append_line_to_content(content, line);
		free(content);
		free(line);
		
		if (!new_content)
			return (NULL);
		
		content = new_content;
	}
	
	init_signals();
	return (content);
} 

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   main.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mahajj-h <mahajj-h@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/27 00:00:00 by mahajj-h          #+#    #+#             */
/*   Updated: 2025/07/27 00:00:00 by mahajj-h         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

volatile sig_atomic_t	g_signal = 0;

static void	sigint_handler(int signo)
{
	(void)signo;
	/* Only handle SIGINT in interactive mode (when reading input) */
	if (g_signal == 0)  /* Only handle if not already processing a signal */
	{
		g_signal = SIGINT;
		write(STDOUT_FILENO, "\n", 1);
		rl_on_new_line();
		rl_replace_line("", 0);
		rl_redisplay();
	}
}

static void	sigquit_handler(int signo)
{
	(void)signo;
	/* Do nothing in interactive mode as required by subject */
}

static void	setup_signals(void)
{
	struct sigaction	sa_int;
	struct sigaction	sa_quit;

	sa_int.sa_handler = sigint_handler;
	sigemptyset(&sa_int.sa_mask);
	sa_int.sa_flags = SA_RESTART;
	sigaction(SIGINT, &sa_int, NULL);
	sa_quit.sa_handler = sigquit_handler;
	sigemptyset(&sa_quit.sa_mask);
	sa_quit.sa_flags = SA_RESTART;
	sigaction(SIGQUIT, &sa_quit, NULL);
}

int	main(int argc, char **argv, char **envp)
{
	char			*line;
	struct s_cmd	*cmd;
	char			**environ_copy;

	(void)argv;
	if (argc != 1)
	{
		ft_putstr_fd("Usage: ./minishell\n", STDERR_FILENO);
		return (1);
	}
	
	/* Copy environment */
	environ_copy = copy_environ(envp);
	if (!environ_copy)
	{
		ft_putstr_fd("Failed to copy environment\n", STDERR_FILENO);
		return (1);
	}
	/* Don't set global environ - we work with our local copy */
	
	setup_signals();
	rl_catch_signals = 0;
	
	while (1)
	{
		init_signals();
		if (handle_line_input(&line))
			continue ;
		if (handle_tokenize(line, &cmd, environ_copy))
			continue ;
		if (cmd)
		{
			if (handle_builtin_cmd(cmd, line, &environ_copy))
			{
				free_cmd(cmd);
				if (line)
					free(line);
				continue ;
			}
			/* Reset signal flag before executing command */
			g_signal = 0;
			execute_cmd(cmd, environ_copy);
			free_cmd(cmd);
		}
		if (line)
			free(line);
	}
	
	/* Clean up on normal exit */
	clean_exit(0);
	return (0);
}


/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   main_helper1.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mahajj-h <mahajj-h@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/27 00:00:00 by mahajj-h          #+#    #+#             */
/*   Updated: 2025/07/27 00:00:00 by mahajj-h         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

int	handle_eof(char *buf, size_t len)
{
	if (len == 0)
	{
		if (isatty(STDIN_FILENO))
			ft_putstr_fd("exit\n", STDOUT_FILENO);
		free(buf);
		clean_exit(0);
	}
	clearerr(stdin);
	return (1);
}

void	init_signals(void)
{
	g_signal = 0;
}

int	handle_line_input(char **line)
{
	g_signal = 0;
	*line = readline("minishell$ ");
	if (!*line)
	{
		ft_putstr_fd("exit\n", STDOUT_FILENO);
		clean_exit(0);
	}
	if (g_signal == SIGINT)
	{
		free(*line);
		*line = NULL;
		return (1);
	}
	if (ft_strlen(*line) > 0)
		add_history(*line);
	return (0);
}


/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   main_helper2.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mahajj-h <mahajj-h@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/27 00:00:00 by mahajj-h          #+#    #+#             */
/*   Updated: 2025/07/27 00:00:00 by mahajj-h         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

int	handle_tokenize(char *line, struct s_cmd **cmd, char **env_copy)
{
	*cmd = tokenize(line, env_copy);
	if (!*cmd)
	{
		free(line);
		return (1);
	}
	return (0);
}

void	execute_cmd(struct s_cmd *cmd, char **env_copy)
{
	int	status;
	pid_t	pid;

	pid = fork();
	if (pid < 0)
	{
		perror("fork failed");
		set_exit_status(1);
		return;
	}
	
	if (pid == 0)
	{
		/* Child process */
		runcmd(cmd, env_copy);
		clean_exit(get_exit_status());
	}
	
	/* Parent process */
	waitpid(pid, &status, 0);
	handle_child_status(status);
}


/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   main_helper3.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mahajj-h <mahajj-h@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/27 00:00:00 by mahajj-h          #+#    #+#             */
/*   Updated: 2025/07/27 00:00:00 by mahajj-h         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

void	expand_builtin_args(struct s_execcmd *ecmd, char **env_copy)
{
	int		i;
	char	*original;

	i = 0;
	while (ecmd->av[i])
	{
		original = ecmd->av[i];
		ecmd->av[i] = expand_variables(original, ft_strlen(original), env_copy);
		free(original);
		i++;
	}
}

int	handle_builtin_cmd(struct s_cmd *cmd, char *line, char ***env_copy)
{
	struct s_execcmd	*ecmd;
	int					status;

	(void)line; /* Parameter not used in this function */
	if (cmd->type == EXEC)
	{
		ecmd = (struct s_execcmd *)cmd;
		if (ecmd->av[0] && is_builtin(ecmd->av[0]))
		{
			expand_builtin_args(ecmd, *env_copy);
			status = handle_builtin(ecmd->av, env_copy);
			set_exit_status(status);
			/* Don't free cmd and line here - let the main loop handle it */
			return (1);
		}
	}
	return (0);
}

void	handle_child_status(int status)
{
	if (WIFSIGNALED(status))
	{
		if (WTERMSIG(status) == SIGINT)
			set_exit_status(130);
		else if (WTERMSIG(status) == SIGQUIT)
			set_exit_status(131);
		else
			set_exit_status(128 + WTERMSIG(status));
	}
	else
	{
		set_exit_status(WEXITSTATUS(status));
	}
}


/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   memory_management.c                                :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   Created: 2025/07/27 00:00:00 by mahajj-h          #+#    #+#             */
/*   Updated: 2025/07/27 00:00:00 by mahajj-h         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

/* Handle SHLVL increment when shell starts */
static void	increment_shlvl(char ***env_copy)
{
	char	*shlvl_value;
	int		shlvl_num;
	char	*new_shlvl;
	int		i;

	/* Find existing SHLVL */
	i = 0;
	while ((*env_copy)[i])
	{
		if (ft_strncmp((*env_copy)[i], "SHLVL=", 6) == 0)
		{
			shlvl_value = (*env_copy)[i] + 6;
			shlvl_num = ft_atoi(shlvl_value);
			
			/* Handle invalid or too large values */
			if (shlvl_num < 0 || shlvl_num >= 1000)
				shlvl_num = 0;
			
			shlvl_num++;
			new_shlvl = ft_itoa(shlvl_num);
			if (new_shlvl)
			{
				free((*env_copy)[i]);
				(*env_copy)[i] = malloc(ft_strlen("SHLVL=") + ft_strlen(new_shlvl) + 1);
				if ((*env_copy)[i])
				{
					ft_strcpy((*env_copy)[i], "SHLVL=");
					ft_strlcat((*env_copy)[i], new_shlvl, ft_strlen("SHLVL=") + ft_strlen(new_shlvl) + 1);
				}
				free(new_shlvl);
			}
			return ;
		}
		i++;
	}
	
	/* SHLVL doesn't exist, add it with value 1 */
	new_shlvl = ft_itoa(1);
	if (new_shlvl)
	{
		ft_setenv("SHLVL", new_shlvl, 1, env_copy);
		free(new_shlvl);
	}
}

/* Copy environment variables from envp to a new array */
char	**copy_environ(char **envp)
{
	char	**new_environ;
	int		i;
	int		count;

	if (!envp)
		return (NULL);
	
	/* Count environment variables */
	count = 0;
	while (envp[count])
		count++;
	
	/* Allocate new environment array */
	new_environ = malloc((count + 1) * sizeof(char *));
	if (!new_environ)
		return (NULL);
	
	/* Copy each environment variable */
	i = 0;
	while (envp[i])
	{
		new_environ[i] = ft_strdup(envp[i]);
		if (!new_environ[i])
		{
			/* Clean up on failure */
			while (i > 0)
			{
				i--;
				free(new_environ[i]);
			}
			free(new_environ);
			return (NULL);
		}
		i++;
	}
	new_environ[i] = NULL;
	
	/* Handle SHLVL increment */
	increment_shlvl(&new_environ);
	
	return (new_environ);
}

/* Free environment copy on exit */
void	free_environ_copy(char **environ_copy)
{
	int	i;

	if (!environ_copy)
		return ;
	
	i = 0;
	while (environ_copy[i])
	{
		if (environ_copy[i])
		{
			free(environ_copy[i]);
			environ_copy[i] = NULL;
		}
		i++;
	}
	free(environ_copy);
}

/* Clean exit function */
void	clean_exit(int status)
{
	/* Don't free global environ - we work with our local copy */
	rl_clear_history();
	exit(status);
}

/* Memory leak check helper for debugging */
#ifdef DEBUG
void	check_leaks(void)
{
	system("leaks minishell");
}
#endif 

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parses.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mahajj-h <mahajj-h@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/27 00:00:00 by mahajj-h          #+#    #+#             */
/*   Updated: 2025/07/27 00:00:00 by mahajj-h         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

struct s_cmd	*parse_pipe(char **input_ptr, char *input_end, char **env_copy)
{
	struct s_cmd	*cmd;
	struct s_cmd	*right;

	cmd = parseexec(input_ptr, input_end, env_copy);
	if (!cmd)
		return (NULL);
	if (peek(input_ptr, input_end, "|"))
	{
		gettoken(input_ptr, input_end, NULL, NULL);
		right = parse_pipe(input_ptr, input_end, env_copy);
		if (!right)
		{
			free_cmd(cmd);
			return (NULL);
		}
		cmd = pipecmd(cmd, right);
		if (!cmd)
			return (NULL);
	}
	return (cmd);
}

struct s_cmd	*parse_line(char **input_ptr, char *input_end, char **env_copy)
{
	struct s_cmd	*cmd;

	cmd = parse_pipe(input_ptr, input_end, env_copy);
	if (!cmd)
		return (NULL);
	if (peek(input_ptr, input_end, "&"))
	{
		gettoken(input_ptr, input_end, NULL, NULL);
		cmd = backcmd(cmd);
		if (!cmd)
			return (NULL);
		if (!peek(input_ptr, input_end, "\0"))
		{
			return (parse_line(input_ptr, input_end, env_copy));
		}
	}
	/* Semicolon handling removed - not supported in this minishell */
	return (cmd);
}

struct s_cmd	*parse_block(char **input_ptr, char *input_end, char **env_copy)
{
	struct s_cmd	*cmd;

	if (!peek(input_ptr, input_end, "("))
	{
		ft_fprintf_stderr("minishell: missing (\n");
		return (NULL);
	}
	gettoken(input_ptr, input_end, NULL, NULL);
	cmd = parse_line(input_ptr, input_end, env_copy);
	if (!cmd)
		return (NULL);
	if (!peek(input_ptr, input_end, ")"))
	{
		ft_fprintf_stderr("minishell: missing )\n");
		free_cmd(cmd);
		return (NULL);
	}
	gettoken(input_ptr, input_end, NULL, NULL);
	return (cmd);
}

struct s_cmd	*parseexec(char **input_ptr, char *input_end, char **env_copy)
{
	struct s_execcmd	*cmd;
	struct s_cmd		*ret;
	int					argc;

	argc = 0;
	if (peek(input_ptr, input_end, "("))
		return (parse_block(input_ptr, input_end, env_copy));
	ret = init_exec_cmd();
	if (!ret)
		return (NULL);
	cmd = (struct s_execcmd *)ret;
	
	/* First parse all arguments and redirections for this command */
	ret = process_arguments_and_redirs(ret,
			(t_process_args_params){cmd, input_ptr, input_end, &argc}, env_copy);
	if (!ret)
		return (NULL);
	
	finalize_exec_cmd(cmd, argc);
	return (ret);
}


/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parses_helper1.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mahajj-h <mahajj-h@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/27 00:00:00 by mahajj-h          #+#    #+#             */
/*   Updated: 2025/07/27 00:00:00 by mahajj-h         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

char	*init_output_buffer(size_t len)
{
	char	*output;

	output = malloc(len + 1);
	if (!output)
		return (NULL);
	return (output);
}

/* Backslash processing removed - not supported in this minishell */
char	*process_escaped(const char *input, size_t len)
{
	char	*output;
	size_t	i;

	output = malloc(len + 1);
	if (!output)
		return (NULL);
	i = 0;
	while (i < len)
	{
		output[i] = input[i];
		i++;
	}
	output[i] = '\0';
	return (output);
}

int	get_redir_token(char **input_ptr, char *input_end,
			char **q, char **eq)
{
	int	tok;

	tok = gettoken(input_ptr, input_end, NULL, NULL);
	if (gettoken(input_ptr, input_end, q, eq) != 'a')
	{
		ft_fprintf_stderr("minishell: missing file name\n");
		return (0);
	}
	return (tok);
}

char	*process_filename(char *q, char *eq, char **env_copy)
{
	size_t	len;
	char	*processed;
	char	*expanded;

	len = eq - q;
	processed = process_escaped(q, len);
	if (!processed)
	{
		ft_fprintf_stderr("minishell: malloc failed\n");
		return (NULL);
	}
	expanded = expand_variables(processed, ft_strlen(processed), env_copy);
	free(processed);
	if (!expanded)
	{
		ft_fprintf_stderr("minishell: malloc failed\n");
		return (NULL);
	}
	return (expanded);
}

struct s_cmd	*handle_redir_token(struct s_cmd *cmd, int tok, char *file)
{
	if (tok == '<')
		return (apply_input_redir(cmd, file));
	else if (tok == '>')
		return (apply_output_redir(cmd, file));
	else if (tok == '+')
		return (apply_append_redir(cmd, file));
	else if (tok == 'H')
		return (handle_heredoc_token(cmd, file));
	return (cmd);
}


/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parses_helper2.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mahajj-h <mahajj-h@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/27 00:00:00 by mahajj-h          #+#    #+#             */
/*   Updated: 2025/07/27 00:00:00 by mahajj-h         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

char	get_escape_char(char c)
{
	if (c == 'n')
		return ('\n');
	else if (c == 't')
		return ('\t');
	else if (c == 'r')
		return ('\r');
	else if (c == 'v')
		return ('\v');
	else if (c == 'b')
		return ('\b');
	else if (c == 'f')
		return ('\f');
	else if (c == 'a')
		return ('\a');
	else if (c == '\\')
		return ('\\');
	else
		return (c);
}

void	handle_escape_sequence(const char *input, size_t *i,
				char *output, size_t *j)
{
	output[(*j)++] = get_escape_char(input[*i + 1]);
	*i += 2;
}

void	remove_redir_quotes(char **q, char **eq)
{
	if (**q == '"' && *(*eq - 1) == '"')
	{
		(*q)++;
		(*eq)--;
	}
}

struct s_cmd	*apply_input_redir(struct s_cmd *cmd, char *file)
{
	return (redircmd(cmd, file, NULL,
			(t_redir_params){O_RDONLY, 0}));
}

struct s_cmd	*apply_output_redir(struct s_cmd *cmd, char *file)
{
	return (redircmd(cmd, file, NULL,
			(t_redir_params){O_WRONLY | O_CREAT | O_TRUNC, 1}));
}


/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parses_helper3.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mahajj-h <mahajj-h@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/27 00:00:00 by mahajj-h          #+#    #+#             */
/*   Updated: 2025/07/27 00:00:00 by mahajj-h         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

struct s_cmd	*apply_append_redir(struct s_cmd *cmd, char *file)
{
	return (redircmd(cmd, file, NULL,
			(t_redir_params){O_WRONLY | O_CREAT | O_APPEND, 1}));
}

struct s_cmd	*init_exec_cmd(void)
{
	struct s_cmd	*ret;

	ret = execcmd();
	return (ret);
}

int	get_exec_token(char **input_ptr, char *input_end, char **q, char **eq)
{
	int	tok;

	tok = gettoken(input_ptr, input_end, q, eq);
	if (tok == 0)
		return (0);
	if (tok != 'a')
	{
		ft_fprintf_stderr("minishell: missing file name\n");
		return (0);
	}
	return (tok);
}

void	remove_exec_quotes(char **q, char **eq)
{
	if (**q == '"' && *(*eq - 1) == '"')
	{
		(*q)++;
		(*eq)--;
	}
	else if (**q == '\'' && *(*eq - 1) == '\'')
	{
		(*q)++;
		(*eq)--;
	}
}

char	*process_argument(char *q, char *eq)
{
	size_t	len;
	char	*processed;

	len = eq - q;
	processed = process_escaped(q, len);
	if (!processed)
	{
		ft_fprintf_stderr("minishell: malloc failed\n");
		return (NULL);
	}
	return (processed);
}


/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parses_helper4.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mahajj-h <mahajj-h@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/27 00:00:00 by mahajj-h          #+#    #+#             */
/*   Updated: 2025/07/27 00:00:00 by mahajj-h         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

void	add_argument(struct s_execcmd *cmd, char *processed, int *argc)
{
	if (*argc >= MAXARGS)
	{
		ft_fprintf_stderr("minishell: too many arguments\n");
		free(processed);
		return;
	}
	cmd->av[*argc] = processed;
	cmd->eav[*argc] = cmd->av[*argc] + ft_strlen(processed);
	(*argc)++;
}

void	finalize_exec_cmd(struct s_execcmd *cmd, int argc)
{
	cmd->av[argc] = 0;
	cmd->eav[argc] = 0;
}

struct s_cmd	*process_arguments(struct s_cmd *ret,
			t_process_args_params params, char **env_copy)
{
	char	*q;
	char	*eq;
	int		tok;
	char	*processed;

	(void)env_copy; /* Parameter not used in this function */
	while (!peek(params.input_ptr, params.input_end, "|)&;"))
	{
		tok = get_exec_token(params.input_ptr, params.input_end, &q, &eq);
		if (tok == 0)
			break ;
		remove_exec_quotes(&q, &eq);
		processed = process_argument(q, eq);
		add_argument(params.cmd, processed, params.argc);
	}
	return (ret);
}

struct s_cmd	*handle_heredoc_token(struct s_cmd *cmd, char *delimiter)
{
	char	*content;
	
	content = read_heredoc_content(delimiter);
	if (!content)
	{
		free(delimiter);
		return (NULL);
	}
	
	return (heredoccmd(cmd, delimiter, content));
}

struct s_cmd	*process_arguments_and_redirs(struct s_cmd *ret,
			t_process_args_params params, char **env_copy)
{
	char	*q;
	char	*eq;
	int		tok;
	char	*processed;
	char	*file_or_delimiter;

	while (!peek(params.input_ptr, params.input_end, "|)&;"))
	{
		tok = gettoken(params.input_ptr, params.input_end, &q, &eq);
		if (tok == 0)
			break ;
		
		/* Check if this is a redirection token */
		if (tok == '<' || tok == '>' || tok == '+' || tok == 'H')
		{
			/* Get the filename/delimiter for the redirection */
			int filename_tok = gettoken(params.input_ptr, params.input_end, &q, &eq);
			if (filename_tok != 'a')
			{
				ft_fprintf_stderr("minishell: missing file name\n");
				free_cmd(ret);
				return (NULL);
			}
			
			/* Process the redirection */
			remove_redir_quotes(&q, &eq);
			file_or_delimiter = process_filename(q, eq, env_copy);
			if (!file_or_delimiter)
			{
				free_cmd(ret);
				return (NULL);
			}
			
			if (tok == 'H')
			{
				ret = handle_heredoc_token(ret, file_or_delimiter);
			}
			else
			{
				ret = handle_redir_token(ret, tok, file_or_delimiter);
			}
			
			if (!ret)
				return (NULL);
		}
		else if (tok == 'a')
		{
			/* This is a regular argument */
			remove_exec_quotes(&q, &eq);
			processed = process_argument(q, eq);
			if (!processed)
			{
				free_cmd(ret);
				return (NULL);
			}
			add_argument(params.cmd, processed, params.argc);
		}
		else
		{
			/* Unexpected token */
			break ;
		}
	}
	return (ret);
}


/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   runner.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mahajj-h <mahajj-h@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/27 00:00:00 by mahajj-h          #+#    #+#             */
/*   Updated: 2025/07/27 00:00:00 by mahajj-h         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

char	*find_command(const char *cmd, char **env_copy)
{
	char	*path;
	char	*result;

	path = get_env_value("PATH", 4, env_copy);
	if (!path || ft_strlen(path) == 0)
		return (NULL);
	result = check_absolute_path(cmd);
	if (result != (char *)1)
	{
		free(path);
		return (result);
	}
	result = search_in_paths(path, cmd);
	free(path);
	return (result);
}

void	run_exec_cmd(struct s_cmd *cmd, char **env_copy)
{
	struct s_execcmd	*ex;

	ex = (struct s_execcmd *)cmd;
	if (ex->av[0] == 0)
		clean_exit(0);
	expand_exec_args(ex, env_copy);
	if (is_builtin(ex->av[0]))
	{
		handle_exec_builtin(ex, cmd, &env_copy);
		return ;
	}
	execute_external_cmd(ex, env_copy);
}

void	run_redir_cmd(struct s_cmd *cmd, char **env_copy)
{
	struct s_redircmd	*rdir;
	int					saved_stdin;
	int					saved_stdout;

	rdir = (struct s_redircmd *)cmd;
	
	/* Save original file descriptors */
	if (rdir->fd == STDIN_FILENO)
		saved_stdin = dup(STDIN_FILENO);
	else if (rdir->fd == STDOUT_FILENO)
		saved_stdout = dup(STDOUT_FILENO);
	
	/* Close the original file descriptor */
	close(rdir->fd);
	
	/* Open the redirection file */
	if ((rdir->mode & O_CREAT) && (rdir->mode & (O_WRONLY | O_RDWR)))
	{
		if (open_redir_file_create(rdir) != 0)
		{
			set_exit_status(1);
			/* Restore file descriptors before exiting */
			if (rdir->fd == STDIN_FILENO)
			{
				dup2(saved_stdin, STDIN_FILENO);
				close(saved_stdin);
			}
			else if (rdir->fd == STDOUT_FILENO)
			{
				dup2(saved_stdout, STDOUT_FILENO);
				close(saved_stdout);
			}
			return;
		}
	}
	else
	{
		if (open_redir_file_regular(rdir) != 0)
		{
			set_exit_status(1);
			/* Restore file descriptors before exiting */
			if (rdir->fd == STDIN_FILENO)
			{
				dup2(saved_stdin, STDIN_FILENO);
				close(saved_stdin);
			}
			else if (rdir->fd == STDOUT_FILENO)
			{
				dup2(saved_stdout, STDOUT_FILENO);
				close(saved_stdout);
			}
			return;
		}
	}
	
	/* Execute the command with redirection */
	runcmd(rdir->cmd, env_copy);
	
	/* Restore original file descriptors */
	if (rdir->fd == STDIN_FILENO)
	{
		dup2(saved_stdin, STDIN_FILENO);
		close(saved_stdin);
	}
	else if (rdir->fd == STDOUT_FILENO)
	{
		dup2(saved_stdout, STDOUT_FILENO);
		close(saved_stdout);
	}
}

/* List command execution removed - semicolon not supported in this minishell */
void	run_list_cmd(struct s_cmd *cmd)
{
	(void)cmd;
}

void	runcmd(struct s_cmd *cmd, char **env_copy)
{
	if (cmd == 0)
		clean_exit(0);
	if (cmd->type == EXEC)
		run_exec_cmd(cmd, env_copy);
	else if (cmd->type == REDIR)
		run_redir_cmd(cmd, env_copy);
	else if (cmd->type == HEREDOC)
		run_heredoc_cmd(cmd, env_copy);
	/* List command handling removed - semicolon not supported in this minishell */
	else if (cmd->type == PIPE)
		run_pipe_cmd(cmd, env_copy);
	else if (cmd->type == BACK)
		run_back_cmd(cmd, env_copy);
	else
	{
		ft_fprintf_stderr("unknown command type: %d\n", cmd->type);
		clean_exit(1);
	}
	// Don't call clean_exit(0) here - let the calling function handle exit
}


/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   runner_helper1.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mahajj-h <mahajj-h@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/27 00:00:00 by mahajj-h          #+#    #+#             */
/*   Updated: 2025/07/27 00:00:00 by mahajj-h         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

char	*check_absolute_path(const char *cmd)
{
	if (cmd[0] == '/' || cmd[0] == '.')
	{
		if (access(cmd, X_OK) == 0)
			return (ft_strdup(cmd));
		return (NULL);
	}
	return ((char *)1);
}

char	*search_in_paths(char *path, const char *cmd)
{
	char	*curr;
	char	*next;
	char	full_path[1024];
	size_t	len;

	curr = path;
	while (curr && *curr)
	{
		len = get_path_segment_len(curr, &next);
		if (build_full_path(full_path, curr, len, cmd))
			return (NULL);
		if (access(full_path, X_OK) == 0)
			return (ft_strdup(full_path));
		if (!next)
			break ;
		curr = next + 1;
	}
	return (NULL);
}

void	expand_exec_args(struct s_execcmd *ex, char **env_copy)
{
	int		i;
	char	*original;

	i = 0;
	while (ex->av[i])
	{
		original = ex->av[i];
		ex->av[i] = expand_variables(original, ft_strlen(original), env_copy);
		free(original);
		i++;
	}
}

void	execute_external_cmd(struct s_execcmd *ex, char **env_copy)
{
	char			*cmd_path;
	pid_t			pid;
	int				status;

	cmd_path = find_command(ex->av[0], env_copy);
	if (!cmd_path)
	{
		ft_fprintf_stderr("minishell: %s: command not found\n", ex->av[0]);
		set_exit_status(127);
		return;
	}
	
	pid = fork();
	if (pid < 0)
	{
		perror("fork failed");
		free(cmd_path);
		set_exit_status(1);
		return;
	}
	
	if (pid == 0)
	{
		/* Child process */
		reset_signals();
		execve(cmd_path, ex->av, env_copy);
		perror("execve failed");
		free(cmd_path);
		clean_exit(1);
	}
	else
	{
		/* Parent process */
		free(cmd_path);
		waitpid(pid, &status, 0);
		
		if (WIFEXITED(status))
			set_exit_status(WEXITSTATUS(status));
		else if (WIFSIGNALED(status))
		{
			if (WTERMSIG(status) == SIGINT)
				set_exit_status(130);
			else if (WTERMSIG(status) == SIGQUIT)
				set_exit_status(131);
			else
				set_exit_status(128 + WTERMSIG(status));
		}
		else
			set_exit_status(1);
	}
}

void	run_pipe_cmd(struct s_cmd *cmd, char **env_copy)
{
	int					p[2];
	struct s_pipecmd	*pipecmd;
	pid_t				pid1;
	pid_t				pid2;
	int					status1;
	int					status2;

	pipecmd = (struct s_pipecmd *)cmd;
	if (pipe(p) < 0)
	{
		perror("pipe failed");
		set_exit_status(1);
		return;
	}
	
	/* Fork first child for left side of pipe */
	pid1 = fork();
	if (pid1 < 0)
	{
		perror("fork failed");
		close(p[0]);
		close(p[1]);
		set_exit_status(1);
		return;
	}
	
	if (pid1 == 0)
	{
		/* Child process - left side of pipe */
		close(p[0]);  /* Close read end */
		dup2(p[1], STDOUT_FILENO);  /* Redirect stdout to pipe write end */
		close(p[1]);
		runcmd(pipecmd->left, env_copy);
		exit(get_exit_status());
	}
	
	/* Fork second child for right side of pipe */
	pid2 = fork();
	if (pid2 < 0)
	{
		perror("fork failed");
		close(p[0]);
		close(p[1]);
		kill(pid1, SIGTERM);
		waitpid(pid1, NULL, 0);
		set_exit_status(1);
		return;
	}
	
	if (pid2 == 0)
	{
		/* Child process - right side of pipe */
		close(p[1]);  /* Close write end */
		dup2(p[0], STDIN_FILENO);  /* Redirect stdin to pipe read end */
		close(p[0]);
		runcmd(pipecmd->right, env_copy);
		exit(get_exit_status());
	}
	
	/* Parent process */
	close(p[0]);
	close(p[1]);
	
	/* Wait for both children with proper signal handling */
	waitpid(pid1, &status1, 0);
	waitpid(pid2, &status2, 0);
	
	/* Set exit status to the rightmost command's status */
	if (WIFEXITED(status2))
		set_exit_status(WEXITSTATUS(status2));
	else if (WIFSIGNALED(status2))
	{
		if (WTERMSIG(status2) == SIGINT)
			set_exit_status(130);
		else if (WTERMSIG(status2) == SIGQUIT)
			set_exit_status(131);
		else
			set_exit_status(128 + WTERMSIG(status2));
	}
	else
		set_exit_status(1);
}


/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   runner_helper2.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mahajj-h <mahajj-h@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/27 00:00:00 by mahajj-h          #+#    #+#             */
/*   Updated: 2025/07/27 00:00:00 by mahajj-h         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

size_t	get_path_segment_len(char *curr, char **next)
{
	size_t	len;

	*next = ft_strchr(curr, ':');
	if (*next)
		len = (size_t)(*next - curr);
	else
		len = ft_strlen(curr);
	return (len);
}

int	build_full_path(char *full_path, char *curr,
					size_t len, const char *cmd)
{
	if (len + ft_strlen(cmd) + 2 > 1024)
	{
		ft_fprintf_stderr("Path too long: %.*s/%s\n", (int)len, curr, cmd);
		return (1);
	}
	ft_strncpy(full_path, curr, len);
	full_path[len] = '/';
	ft_strcpy(full_path + len + 1, cmd);
	return (0);
}

void	reset_signals(void)
{
	struct sigaction	sa;

	sa.sa_handler = SIG_DFL;
	sigemptyset(&sa.sa_mask);
	sa.sa_flags = SA_RESTART;
	sigaction(SIGINT, &sa, NULL);
	sigaction(SIGQUIT, &sa, NULL);
}

void	handle_exec_builtin(struct s_execcmd *ex, struct s_cmd *cmd, char ***env_copy)
{
	int	status;

	(void)cmd;
	status = handle_builtin(ex->av, env_copy);
	set_exit_status(status);
	/* Don't call clean_exit - let the calling function handle the flow */
}

int	open_redir_file_create(struct s_redircmd *rdir)
{
	int	fd;
	int	save_errno;

	fd = open(rdir->file, rdir->mode, 0644);
	if (fd < 0)
	{
		save_errno = errno;
		ft_fprintf_stderr("open failed: %s: %s\n", rdir->file,
			strerror(save_errno));
		return (1);
	}
	if (fd != rdir->fd)
	{
		if (dup2(fd, rdir->fd) < 0)
		{
			save_errno = errno;
			ft_fprintf_stderr("dup2 failed: %s\n", strerror(save_errno));
			close(fd);
			return (1);
		}
		close(fd);
	}
	return (0);
}


/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   runner_helper3.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mahajj-h <mahajj-h@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/27 00:00:00 by mahajj-h          #+#    #+#             */
/*   Updated: 2025/07/27 00:00:00 by mahajj-h         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

int	open_redir_file_regular(struct s_redircmd *rdir)
{
	int	fd;
	int	save_errno;

	fd = open(rdir->file, rdir->mode);
	if (fd < 0)
	{
		save_errno = errno;
		ft_fprintf_stderr("open failed: %s: %s\n", rdir->file,
			strerror(save_errno));
		return (1);
	}
	if (fd != rdir->fd)
	{
		if (dup2(fd, rdir->fd) < 0)
		{
			save_errno = errno;
			ft_fprintf_stderr("dup2 failed: %s\n", strerror(save_errno));
			close(fd);
			return (1);
		}
		close(fd);
	}
	return (0);
}

/* List command functions removed - semicolon not supported in this minishell */
void	handle_list_builtin(struct s_execcmd *ex)
{
	(void)ex;
}

void	handle_list_external(struct s_cmd *cmd)
{
	(void)cmd;
}

void	process_list_left(struct s_listcmd *list)
{
	(void)list;
}

void	process_list_right(struct s_listcmd *list)
{
	(void)list;
}


/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   runner_helper4.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mahajj-h <mahajj-h@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/27 00:00:00 by mahajj-h          #+#    #+#             */
/*   Updated: 2025/07/27 00:00:00 by mahajj-h         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

/* These functions are no longer used - pipe handling is now done in run_pipe_cmd */
void	setup_pipe_left(int *p, struct s_pipecmd *pipecmd, char **env_copy)
{
	(void)p;
	(void)pipecmd;
	(void)env_copy;
}

void	setup_pipe_right(int *p, struct s_pipecmd *pipecmd, char **env_copy)
{
	(void)p;
	(void)pipecmd;
	(void)env_copy;
}

void	run_back_cmd(struct s_cmd *cmd, char **env_copy)
{
	struct s_backcmd	*back;
	pid_t				pid1;
	pid_t				pid2;

	back = (struct s_backcmd *)cmd;
	
	pid1 = fork();
	if (pid1 < 0)
	{
		perror("fork failed");
		set_exit_status(1);
		return;
	}
	
	if (pid1 == 0)
	{
		/* First child - create background process */
		pid2 = fork();
		if (pid2 < 0)
		{
			perror("fork failed");
			clean_exit(1);
		}
		
		if (pid2 == 0)
		{
			/* Second child - actual background command */
			runcmd(back->cmd, env_copy);
			clean_exit(get_exit_status());
		}
		
		/* First child exits immediately */
		clean_exit(0);
	}
	
	/* Parent waits for first child only */
	waitpid(pid1, NULL, 0);
}

void	run_heredoc_cmd(struct s_cmd *cmd, char **env_copy)
{
	struct s_heredoccmd	*hcmd;
	int					pipe_fd[2];
	pid_t				pid;
	int					status;
	int					saved_stdin;

	hcmd = (struct s_heredoccmd *)cmd;
	
	/* Save original stdin */
	saved_stdin = dup(STDIN_FILENO);
	if (saved_stdin < 0)
	{
		perror("dup failed");
		set_exit_status(1);
		return;
	}
	
	if (pipe(pipe_fd) < 0)
	{
		perror("pipe failed");
		close(saved_stdin);
		set_exit_status(1);
		return;
	}
	
	pid = fork();
	if (pid < 0)
	{
		perror("fork failed");
		close(pipe_fd[0]);
		close(pipe_fd[1]);
		close(saved_stdin);
		set_exit_status(1);
		return;
	}
	
	if (pid == 0)
	{
		/* Child process - write heredoc content to pipe */
		close(pipe_fd[0]);
		
		if (hcmd->content && ft_strlen(hcmd->content) > 0)
		{
			write(pipe_fd[1], hcmd->content, ft_strlen(hcmd->content));
		}
		close(pipe_fd[1]);
		clean_exit(0);
	}
	else
	{
		/* Parent process */
		close(pipe_fd[1]);
		
		waitpid(pid, &status, 0);
		
		/* Check if child failed */
		if (WIFEXITED(status) && WEXITSTATUS(status) != 0)
		{
			close(pipe_fd[0]);
			close(saved_stdin);
			set_exit_status(WEXITSTATUS(status));
			return;
		}
		
		/* Redirect stdin to pipe */
		if (dup2(pipe_fd[0], STDIN_FILENO) < 0)
		{
			perror("dup2 failed");
			close(pipe_fd[0]);
			close(saved_stdin);
			set_exit_status(1);
			return;
		}
		close(pipe_fd[0]);
		
		/* Execute the command */
		runcmd(hcmd->cmd, env_copy);
		
		/* Restore original stdin */
		dup2(saved_stdin, STDIN_FILENO);
		close(saved_stdin);
	}
}


/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   tokenize.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mahajj-h <mahajj-h@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/27 00:00:00 by mahajj-h          #+#    #+#             */
/*   Updated: 2025/07/27 00:00:00 by mahajj-h         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

int	gettoken(char **input_ptr, char *input_end,
			char **token_start, char **token_end)
{
	char	*s;
	int		ret;
	char	space[6];
	char	symbols[8];

	init_token_arrays(space, symbols);
	setup_token_processing(input_ptr, input_end, token_start, &s);
	ret = *s;
	if (*s == 0)
		;
	else
		ret = handle_token_cases(&s, *input_ptr, input_end);
	if (token_end)
		*token_end = s;
	s = skip_whitespace(s, input_end, space);
	*input_ptr = s;
	return (ret);
}

int	peek(char **input_ptr, char *input_end, char *toks)
{
	char	*s;
	char	space[6];

	init_space_array(space);
	s = *input_ptr;
	while (s < input_end && ft_strchr(space, *s))
		s++;
	return (*s && ft_strchr(toks, *s));
}

struct s_cmd	*tokenize(const char *line, char **env_copy)
{
	char			*input;
	char			*input_ptr;
	char			*input_end;
	struct s_cmd	*cmd;

	input = ft_strdup(line);
	if (!input)
		return (NULL);
	input_ptr = input;
	input_end = input + ft_strlen(input);
	cmd = parse_line(&input_ptr, input_end, env_copy);
	peek(&input_ptr, input_end, "\0");
	if (input_ptr != input_end)
	{
		ft_fprintf_stderr("minishell: syntax error\n");
		free_cmd(cmd);
		free(input);
		return (NULL);
	}
	free(input);
	return (cmd);
}


/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   tokenize_helper1.c                                :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mahajj-h <mahajj-h@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/27 00:00:00 by mahajj-h          #+#    #+#             */
/*   Updated: 2025/07/27 00:00:00 by mahajj-h         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

/* Backslash handling removed - not supported in this minishell */
int	is_escaped(const char *s, const char *start)
{
	(void)s;
	(void)start;
	return (0);
}

char	*skip_whitespace(char *s, char *input_end, char *space)
{
	while (s < input_end && ft_strchr(space, *s))
		s++;
	return (s);
}

int	handle_special_chars(char **s_ptr, char *input_ptr)
{
	int	ret;

	ret = handle_basic_symbols(s_ptr, input_ptr);
	if (ret != -1)
		return (ret);
	ret = handle_greater_than(s_ptr, input_ptr);
	if (ret != -1)
		return (ret);
	ret = handle_less_than(s_ptr, input_ptr);
	if (ret != -1)
		return (ret);
	return ('a');
}

char	*handle_default_token(char *s, char *input_end, char *input_ptr,
								t_token_params params)
{
	char	quote;

	(void)input_ptr;
	quote = 0;
	while (s < input_end)
	{
		if (!quote)
		{
			if (ft_strchr(params.symbols, *s) || ft_strchr(params.space, *s))
				break ;
			if (*s == '"' || *s == '\'')
				quote = *s;
		}
		else if (quote && *s == quote)
		{
			quote = 0;
		}
		s++;
	}
	return (s);
}

int	handle_token_cases(char **s_ptr, char *input_ptr,
								char *input_end)
{
	int							ret;
	t_process_default_params	params;
	char						space[6];
	char						symbols[8];

	init_token_arrays(space, symbols);
	ret = handle_special_chars(s_ptr, input_ptr);
	if (ret == 'a')
	{
		params.s_ptr = s_ptr;
		params.input_end = input_end;
		params.input_ptr = input_ptr;
		params.symbols = symbols;
		params.space = space;
		ret = process_default_case(s_ptr, input_end, params);
	}
	return (ret);
}


/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   tokenize_helper2.c                                :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mahajj-h <mahajj-h@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/27 00:00:00 by mahajj-h          #+#    #+#             */
/*   Updated: 2025/07/27 00:00:00 by mahajj-h         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

int	handle_basic_symbols(char **s_ptr, char *input_ptr)
{
	char	*s;
	int		ret;

	s = *s_ptr;
	ret = *s;
	if (*s == '|' || *s == '&' || *s == '('
		|| *s == ')')
	{
		if (!is_escaped(s, input_ptr))
		{
			s++;
			*s_ptr = s;
			return (ret);
		}
		*s_ptr = s;
		return ('a');
	}
	*s_ptr = s;
	return (-1);
}

int	handle_greater_than(char **s_ptr, char *input_ptr)
{
	char	*s;
	int		ret;

	s = *s_ptr;
	ret = *s;
	if (*s == '>')
	{
		if (!is_escaped(s, input_ptr))
		{
			s++;
			if (*s == '>' && !is_escaped(s, input_ptr))
			{
				ret = '+';
				s++;
			}
			*s_ptr = s;
			return (ret);
		}
		*s_ptr = s;
		return ('a');
	}
	*s_ptr = s;
	return (-1);
}

void	init_space_array(char *space)
{
	space[0] = ' ';
	space[1] = '\t';
	space[2] = '\r';
	space[3] = '\n';
	space[4] = '\v';
	space[5] = '\0';
}

void	init_symbols_array(char *symbols)
{
	symbols[0] = '<';
	symbols[1] = '>';
	symbols[2] = '|';
	symbols[3] = '&';
	symbols[4] = '(';
	symbols[5] = ')';
	symbols[6] = '\0';
}

int	handle_less_than(char **s_ptr, char *input_ptr)
{
	char	*s;
	int		ret;

	s = *s_ptr;
	ret = *s;
	if (*s == '<')
	{
		if (!is_escaped(s, input_ptr))
		{
			s++;
			if (*s == '<' && !is_escaped(s, input_ptr))
			{
				ret = 'H';
				s++;
			}
			*s_ptr = s;
			return (ret);
		}
		*s_ptr = s;
		return ('a');
	}
	*s_ptr = s;
	return (-1);
}


/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   tokenize_helper3.c                                :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mahajj-h <mahajj-h@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/27 00:00:00 by mahajj-h          #+#    #+#             */
/*   Updated: 2025/07/27 00:00:00 by mahajj-h         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

t_token_params	setup_token_params(char *s, char *input_end,
								t_token_params params)
{
	params.s = s;
	params.input_end = input_end;
	return (params);
}

int	process_default_case(char **s_ptr, char *input_end,
								t_process_default_params params)
{
	t_token_params	token_params;

	token_params.input_ptr = params.input_ptr;
	token_params.symbols = params.symbols;
	token_params.space = params.space;
	token_params = setup_token_params(*s_ptr, input_end, token_params);
	*s_ptr = handle_default_token(*s_ptr, input_end, params.input_ptr,
			token_params);
	return ('a');
}

void	setup_token_processing(char **input_ptr, char *input_end,
								char **token_start, char **s_ptr)
{
	char	space[6];
	char	symbols[8];

	init_token_arrays(space, symbols);
	*s_ptr = *input_ptr;
	*s_ptr = skip_whitespace(*s_ptr, input_end, space);
	if (token_start)
		*token_start = *s_ptr;
}

void	init_token_arrays(char *space, char *symbols)
{
	init_space_array(space);
	init_symbols_array(symbols);
}


/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   utils1.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mahajj-h <mahajj-h@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/27 00:00:00 by mahajj-h          #+#    #+#             */
/*   Updated: 2025/07/27 00:00:00 by mahajj-h         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

void	handle_redir_case(struct s_cmd *cmd)
{
	struct s_redircmd	*rcmd;

	if (!cmd)
		return ;
	
	rcmd = (struct s_redircmd *)cmd;
	if (rcmd->cmd)
		nulterm(rcmd->cmd);
	if (rcmd->efile)
		*rcmd->efile = 0;
}

void	handle_pipe_case(struct s_cmd *cmd)
{
	struct s_pipecmd	*pcmd;

	if (!cmd)
		return ;
	
	pcmd = (struct s_pipecmd *)cmd;
	if (pcmd->left)
		nulterm(pcmd->left);
	if (pcmd->right)
		nulterm(pcmd->right);
}

/* List command handling removed - semicolon not supported in this minishell */
void	handle_list_case(struct s_cmd *cmd)
{
	(void)cmd;
}

void	handle_back_case(struct s_cmd *cmd)
{
	struct s_backcmd	*bcmd;

	if (!cmd)
		return ;
	
	bcmd = (struct s_backcmd *)cmd;
	if (bcmd->cmd)
		nulterm(bcmd->cmd);
}

void	handle_heredoc_case(struct s_cmd *cmd)
{
	struct s_heredoccmd	*hcmd;

	if (!cmd)
		return ;
	
	hcmd = (struct s_heredoccmd *)cmd;
	if (hcmd->cmd)
		nulterm(hcmd->cmd);
}

void	free_cmd(struct s_cmd *cmd)
{
	if (!cmd)
		return ;
	
	if (cmd->type == EXEC)
		free_exec_cmd((struct s_execcmd *)cmd);
	else if (cmd->type == REDIR)
		free_redir_cmd((struct s_redircmd *)cmd);
	else if (cmd->type == HEREDOC)
		free_heredoc_cmd((struct s_heredoccmd *)cmd);
	else if (cmd->type == PIPE)
		free_pipe_cmd((struct s_pipecmd *)cmd);
	/* List command handling removed - semicolon not supported in this minishell */
	else if (cmd->type == BACK)
		free_back_cmd((struct s_backcmd *)cmd);
}


/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   utils2.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mahajj-h <mahajj-h@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/27 00:00:00 by mahajj-h          #+#    #+#             */
/*   Updated: 2025/07/27 00:00:00 by mahajj-h         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

void	free_exec_cmd(struct s_execcmd *ecmd)
{
	int	i;

	if (!ecmd)
		return ;
	
	i = 0;
	while (ecmd->av[i])
	{
		if (ecmd->av[i])
		{
			free(ecmd->av[i]);
			ecmd->av[i] = NULL;
		}
		i++;
	}
	free(ecmd);
}

void	free_redir_cmd(struct s_redircmd *rcmd)
{
	if (!rcmd)
		return ;
	
	if (rcmd->cmd)
		free_cmd(rcmd->cmd);
	
	if (rcmd->file)
	{
		free(rcmd->file);
		rcmd->file = NULL;
	}
	
	if (rcmd->efile)
	{
		free(rcmd->efile);
		rcmd->efile = NULL;
	}
	
	free(rcmd);
}

void	free_pipe_cmd(struct s_pipecmd *pcmd)
{
	if (!pcmd)
		return ;
	
	if (pcmd->left)
		free_cmd(pcmd->left);
	
	if (pcmd->right)
		free_cmd(pcmd->right);
	
	free(pcmd);
}

/* List command freeing removed - semicolon not supported in this minishell */
void	free_list_cmd(struct s_listcmd *lcmd)
{
	(void)lcmd;
}

void	free_back_cmd(struct s_backcmd *bcmd)
{
	if (!bcmd)
		return ;
	
	if (bcmd->cmd)
		free_cmd(bcmd->cmd);
	
	free(bcmd);
}

void	free_heredoc_cmd(struct s_heredoccmd *hcmd)
{
	if (!hcmd)
		return ;
	
	if (hcmd->cmd)
		free_cmd(hcmd->cmd);
	
	if (hcmd->delimiter)
	{
		free(hcmd->delimiter);
		hcmd->delimiter = NULL;
	}
	
	if (hcmd->content)
	{
		free(hcmd->content);
		hcmd->content = NULL;
	}
	
	free(hcmd);
}


/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   utils3.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mahajj-h <mahajj-h@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/27 00:00:00 by mahajj-h          #+#    #+#             */
/*   Updated: 2025/07/27 00:00:00 by mahajj-h         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"
#include <stdarg.h>

/* Custom strcmp implementation */
int	ft_strcmp(const char *s1, const char *s2)
{
	while (*s1 && *s2 && *s1 == *s2)
	{
		s1++;
		s2++;
	}
	return ((unsigned char)*s1 - (unsigned char)*s2);
}

/* Custom snprintf implementation for simple cases */
int	ft_snprintf(char *str, size_t size, const char *format, ...)
{
	va_list	args;
	int		result;

	va_start(args, format);
	result = ft_vsnprintf(str, size, format, args);
	va_end(args);
	return (result);
}

/* Custom vsnprintf implementation for simple cases */
int	ft_vsnprintf(char *str, size_t size, const char *format, va_list args)
{
	int		i;
	int		num;
	char	*num_str;

	i = 0;
	while (*format && i < (int)size - 1)
	{
		if (*format == '%' && *(format + 1) == 'd')
		{
			num = va_arg(args, int);
			num_str = ft_itoa(num);
			if (!num_str)
				return (-1);
			while (*num_str && i < (int)size - 1)
			{
				str[i++] = *num_str++;
			}
			free(num_str);
			format += 2;
		}
		else if (*format == '%' && *(format + 1) == 's')
		{
			char *s = va_arg(args, char *);
			for (int j = 0; s && s[j] && i < (int)size - 1; j++)
				str[i++] = s[j];
			format += 2;
		}
		else
		{
			str[i++] = *format++;
		}
	}
	str[i] = '\0';
	return (i);
}

/* Custom realloc implementation */
void	*ft_realloc(void *ptr, size_t size)
{
	void	*new_ptr;

	if (!ptr)
		return (malloc(size));
	if (size == 0)
	{
		free(ptr);
		return (NULL);
	}
	new_ptr = malloc(size);
	if (!new_ptr)
		return (NULL);
	ft_memcpy(new_ptr, ptr, size);
	free(ptr);
	return (new_ptr);
}

/* Custom strncpy implementation */
char	*ft_strncpy(char *dest, const char *src, size_t n)
{
	size_t	i;

	i = 0;
	while (i < n && src[i])
	{
		dest[i] = src[i];
		i++;
	}
	while (i < n)
	{
		dest[i] = '\0';
		i++;
	}
	return (dest);
}

/* Custom strcpy implementation */
char	*ft_strcpy(char *dest, const char *src)
{
	char	*ptr;

	ptr = dest;
	while (*src)
	{
		*ptr = *src;
		ptr++;
		src++;
	}
	*ptr = '\0';
	return (dest);
}

/* Custom fflush implementation for stdout */
int	ft_fflush_stdout(void)
{
	/* Force stdout to be flushed by writing a null byte */
	return (write(STDOUT_FILENO, "", 0));
}

/* Custom fprintf implementation for stderr */
int	ft_fprintf_stderr(const char *format, ...)
{
	va_list	args;
	char	buffer[1024];
	int		len;

	va_start(args, format);
	len = ft_vsnprintf(buffer, sizeof(buffer), format, args);
	va_end(args);
	if (len > 0)
		write(STDERR_FILENO, buffer, len);
	return (len);
}

/* Custom setenv implementation */
int	ft_setenv(const char *name, const char *value, int overwrite, char ***env_copy)
{
	int			i;
	int			name_len;
	char		*new_var;
	char		**new_environ;
	char		**old_environ;

	if (!name || !*name || ft_strchr(name, '=') || !env_copy || !*env_copy)
		return (-1);
	name_len = ft_strlen(name);
	i = 0;
	while ((*env_copy)[i])
	{
		if (ft_strncmp((*env_copy)[i], name, name_len) == 0 && (*env_copy)[i][name_len] == '=')
		{
			if (!overwrite)
				return (0);
			/* Variable exists, just update it */
			new_var = malloc(ft_strlen(name) + ft_strlen(value) + 2);
			if (!new_var)
				return (-1);
			ft_strcpy(new_var, name);
			ft_strlcat(new_var, "=", ft_strlen(name) + 2);
			ft_strlcat(new_var, value, ft_strlen(name) + ft_strlen(value) + 2);
			free((*env_copy)[i]);
			(*env_copy)[i] = new_var;
			return (0);
		}
		i++;
	}
	
	/* Variable doesn't exist, add it */
	new_var = malloc(ft_strlen(name) + ft_strlen(value) + 2);
	if (!new_var)
		return (-1);
	ft_strcpy(new_var, name);
	ft_strlcat(new_var, "=", ft_strlen(name) + 2);
	ft_strlcat(new_var, value, ft_strlen(name) + ft_strlen(value) + 2);
	
	/* Count existing variables */
	i = 0;
	while ((*env_copy)[i])
		i++;
	
	/* Allocate new array */
	new_environ = malloc((i + 2) * sizeof(char *));
	if (!new_environ)
	{
		free(new_var);
		return (-1);
	}
	
	/* Copy existing variables */
	i = 0;
	while ((*env_copy)[i])
	{
		new_environ[i] = (*env_copy)[i];
		i++;
	}
	new_environ[i] = new_var;
	new_environ[i + 1] = NULL;
	
	/* Update pointer and free old array */
	old_environ = *env_copy;
	*env_copy = new_environ;
	free(old_environ);
	
	return (0);
}

/* Custom unsetenv implementation */
int	ft_unsetenv(const char *name, char ***env_copy)
{
	int			i;
	int			name_len;
	char		**new_environ;
	int			j;
	int			total_vars;
	int			var_index;

	if (!name || !*name || ft_strchr(name, '=') || !env_copy || !*env_copy)
		return (-1);
	name_len = ft_strlen(name);
	i = 0;
	while ((*env_copy)[i])
	{
		if (ft_strncmp((*env_copy)[i], name, name_len) == 0 && (*env_copy)[i][name_len] == '=')
		{
			var_index = i;
			break ;
		}
		i++;
	}
	if (!(*env_copy)[i])
		return (0);
	
	/* Count total variables */
	total_vars = 0;
	while ((*env_copy)[total_vars])
		total_vars++;
	
	/* Free the variable being removed */
	free((*env_copy)[var_index]);
	
	new_environ = malloc((total_vars) * sizeof(char *));
	if (!new_environ)
		return (-1);
	
	i = 0;
	j = 0;
	while ((*env_copy)[i])
	{
		if (i != var_index)
		{
			new_environ[j] = (*env_copy)[i];
			j++;
		}
		i++;
	}
	new_environ[j] = NULL;
	
	/* Free the old environment array */
	free(*env_copy);
	*env_copy = new_environ;
	return (0);
} 

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   utils.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mahajj-h <mahajj-h@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/27 00:00:00 by mahajj-h          #+#    #+#             */
/*   Updated: 2025/07/27 00:00:00 by mahajj-h         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

void	*get_cwd(char *buf, size_t size)
{
	if (getcwd(buf, size) == NULL)
	{
		perror("getcwd is dead");
		return (NULL);
	}
	return (buf);
}

int	forkk(void)
{
	int	pid;

	pid = fork();
	if (pid == -1)
	{
		perror("fork failed");
		return (-1);
	}
	return (pid);
}

void	wtf(void)
{
	ft_putstr_fd("minishell: internal error\n", STDERR_FILENO);
	clean_exit(1);
}

void	handle_exec_case(struct s_cmd *cmd)
{
	int					i;
	struct s_execcmd	*ecmd;

	ecmd = (struct s_execcmd *)cmd;
	i = 0;
	while (ecmd->av[i])
	{
		*ecmd->eav[i] = 0;
		i++;
	}
}

struct s_cmd	*nulterm(struct s_cmd *cmd)
{
	if (cmd == 0)
		return (0);
	if (cmd->type == EXEC)
		handle_exec_case(cmd);
	else if (cmd->type == REDIR)
		handle_redir_case(cmd);
	else if (cmd->type == HEREDOC)
		handle_heredoc_case(cmd);
	else if (cmd->type == PIPE)
		handle_pipe_case(cmd);
	/* List command handling removed - semicolon not supported in this minishell */
	else if (cmd->type == BACK)
		handle_back_case(cmd);
	return (cmd);
}


CC = cc
CFLAGS = -Wall -Wextra -Werror -D_DEFAULT_SOURCE -D_XOPEN_SOURCE=600

NAME = minishell

SRC_DIR = src
INC_DIR = inc
LIBFT_DIR = inc/libft
OBJ_DIR = obj

SRCS = $(wildcard $(SRC_DIR)/*.c)
OBJS = $(patsubst $(SRC_DIR)/%.c,$(OBJ_DIR)/%.o,$(SRCS))

all: $(NAME)

$(NAME): $(OBJS) $(LIBFT_DIR)/libft.a
	$(CC) $(CFLAGS) -I$(INC_DIR) -I$(LIBFT_DIR) -o $@ $(OBJS) -L$(LIBFT_DIR) -lft -lreadline

# General rule for object files
$(OBJ_DIR)/%.o: $(SRC_DIR)/%.c | $(OBJ_DIR)
	$(CC) $(CFLAGS) -I$(INC_DIR) -I$(LIBFT_DIR) -c $< -o $@

$(OBJ_DIR):
	mkdir -p $(OBJ_DIR)

$(LIBFT_DIR)/libft.a:
	$(MAKE) -C $(LIBFT_DIR)

clean:
	rm -f $(OBJ_DIR)/*.o
	$(MAKE) -C $(LIBFT_DIR) clean

fclean: clean
	rm -f $(NAME)
	$(MAKE) -C $(LIBFT_DIR) fclean

re: fclean all

.PHONY: all clean fclean re
